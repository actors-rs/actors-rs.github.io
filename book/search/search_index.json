{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"actors.html","text":"Getting Started This guide will take you through the fundamentals of the Riker Framework, starting with the basics of the Actor Model through to more advanced topics such as application resilience. If you're familiar with the Actor Model and have used other actor frameworks, you will find Riker familiar. In particular, Riker has been inspired by Scala's Akka and has adopted some of the core concepts and terminology from that project. If you've never used actors in application development before, this documentation aims to be concise and easy to understand. No prior knowledge of actors is necessary. We welcome and encourage contributions to this guide. Please feel free to create Github issues with feedback or create PRs with changes. This documentation's source lives at: https://github.com/riker-rs/website . Note Riker is pre-1.0, and as such the framework is evolving. You can expect some API-level changes, but we do strive to keep breaking changes to an absolute minimum. Between versions 0.1 to 0.2.3 there was only one minor API change, for example. Actors The actor model is a conceptual model to deal with concurrent computation 1 . At the core of the Riker framework are four main components: ActorSystem - Every Riker application has an ActorSystem that manages actor lifecycles Actor - Rust types that implement the Actor trait so they may receive messages Props - Each Actor requires a Props to describe how an Actor should be created ActorRef - A lightweight type that is inexpensive to clone and can be used to interact with its underlying Actor , such as sending messages to it Let's look at each of these and see how a simple application is created. Defining Actors An Actor is the fundamental unit of computation. Actors communicate solely through messages in an asynchronous fashion. An actor can perform three distinct actions based on the message it receives: send a finite number of messages to other actors create a finite number of new actors change its state or designate the behavior to be used for the next message it receives Actors interact with each other by passing messages. There is no assumed order to the above actions, and they could be carried out concurrently. Two messages that are sent concurrently can arrive in either order. To define an actor, the system needs to understand how an actor should handle the messages it receives. To do this, implement the Actor trait on your data type and, at a minimum, provide a recv method. Here's the Rust code: use actors_rs :: * ; struct MyActor ; impl Actor for MyActor { type Msg = String ; fn recv ( & mut self , _ctx : & Context < String > , msg : String , _sender : Sender ) { println ! ( \"received {}\" , msg ); } } fn main () {} In this example, a simple struct MyActor implements the Actor trait. When a message is sent to MyActor , it is scheduled by the system for immediate execution. The recv function is invoked and the message is printed to stdout. Creating Actors Every application has an ActorSystem . The actor system provides actor management and the runtime to execute actors when they're sent messages. It also provides essential services such as starting actors and exposing system services. To start the actor system: use actors_rs :: * ; fn main () { let sys = ActorSystem :: new (). unwrap (); } Here we see that the actor is started using ActorSystem::new . Once we've started the actor system we're ready to create some actors. We can also configure the system with a custom name using the SystemBuilder : use actors_rs :: * ; fn main () { let sys = SystemBuilder :: new () . name ( \"my-app\" ) . create () . unwrap (); } Once the actor system is started, we can begin to create actors: use actors_rs :: * ; #[derive(Default)] struct MyActor ; impl Actor for MyActor { type Msg = String ; fn recv ( & mut self , _ctx : & Context < String > , msg : String , _sender : Sender ) { println ! ( \"received {}\" , msg ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let my_actor = sys . actor_of :: < MyActor > ( \"my-actor\" ). unwrap (); } actor_of used to create an instance of the actor. A my-actor name is also required so that we can look it up later if we need. Although this is just two lines of code, a lot is happening behind the scenes. Actor lifecycles and state are managed by the system. When an actor starts, it keeps the properties in case it needs it again to restart the actor if it fails. When an actor is created, it gets its own mailbox for receiving messages and other interested actors are notified about the new actor joining the system. Actor References When an actor is started using actor_of , the system returns a reference to the actor, an ActorRef . The actual actor instance remains inaccessible directly, its lifecycle being managed and protected by the system. In Rust terms, the system has and always maintains 'ownership' of the actor instance. When you're interacting with actors, you're actually interacting with the actor's ActorRef ! This is a core concept of the actor model. An ActorRef always refers to a specific instance of an actor. When two instances of the same Actor are started, they're still considered separate actors, each with different ActorRef s. ActorRef s are inexpensive and can be cloned (they implement Clone ) without too much concern about resources. References can also be used in Props as a field in another actor's factory method, a pattern known as endowment. ActorRef s can be sent as a message to another actor, a pattern known as introduction. TODO: put example here Sending Messages Actors communicate only through sending and receiving messages. They are isolated and never expose their state or behavior. If we want to send a message to an actor, we use the tell method on the actor's ActorRef : basic.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Default)] struct MyActor ; // implement the Actor trait impl Actor for MyActor { type Msg = String ; fn recv ( & mut self , _ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Sender ) { println ! ( \"Received: {}\" , msg ); } } // start the system and create an actor fn main () { let sys = ActorSystem :: new (). unwrap (); let my_actor = sys . actor_of :: < MyActor > ( \"my-actor\" ). unwrap (); my_actor . tell ( \"Hello my actor!\" . to_string (), None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); } Here, we've sent a message of type String to our MyActor actor. The second parameter lets us specify a sender as an Option<BasicActorRef> (type alias Sender ). Since we're sending the message from main and not from an actor, we're setting the sender as None . Message Guarantees Riker provides certain guarantees when handling messages: Message delivery is 'at-most-once'. A message will either fail to be delivered, or be delivered one time. There is no repeat delivery of the same message. An actor handles one message at any time. Messages are stored in an actor's mailbox in the order that they are received. On this page, you learned the basics of creating a Riker application using actors. Let's move on to the next section to see more comprehensive example using multiple message types: Sending multiple message types","title":"Actors"},{"location":"actors.html#getting-started","text":"This guide will take you through the fundamentals of the Riker Framework, starting with the basics of the Actor Model through to more advanced topics such as application resilience. If you're familiar with the Actor Model and have used other actor frameworks, you will find Riker familiar. In particular, Riker has been inspired by Scala's Akka and has adopted some of the core concepts and terminology from that project. If you've never used actors in application development before, this documentation aims to be concise and easy to understand. No prior knowledge of actors is necessary. We welcome and encourage contributions to this guide. Please feel free to create Github issues with feedback or create PRs with changes. This documentation's source lives at: https://github.com/riker-rs/website . Note Riker is pre-1.0, and as such the framework is evolving. You can expect some API-level changes, but we do strive to keep breaking changes to an absolute minimum. Between versions 0.1 to 0.2.3 there was only one minor API change, for example.","title":"Getting Started"},{"location":"actors.html#actors","text":"The actor model is a conceptual model to deal with concurrent computation 1 . At the core of the Riker framework are four main components: ActorSystem - Every Riker application has an ActorSystem that manages actor lifecycles Actor - Rust types that implement the Actor trait so they may receive messages Props - Each Actor requires a Props to describe how an Actor should be created ActorRef - A lightweight type that is inexpensive to clone and can be used to interact with its underlying Actor , such as sending messages to it Let's look at each of these and see how a simple application is created.","title":"Actors"},{"location":"actors.html#defining-actors","text":"An Actor is the fundamental unit of computation. Actors communicate solely through messages in an asynchronous fashion. An actor can perform three distinct actions based on the message it receives: send a finite number of messages to other actors create a finite number of new actors change its state or designate the behavior to be used for the next message it receives Actors interact with each other by passing messages. There is no assumed order to the above actions, and they could be carried out concurrently. Two messages that are sent concurrently can arrive in either order. To define an actor, the system needs to understand how an actor should handle the messages it receives. To do this, implement the Actor trait on your data type and, at a minimum, provide a recv method. Here's the Rust code: use actors_rs :: * ; struct MyActor ; impl Actor for MyActor { type Msg = String ; fn recv ( & mut self , _ctx : & Context < String > , msg : String , _sender : Sender ) { println ! ( \"received {}\" , msg ); } } fn main () {} In this example, a simple struct MyActor implements the Actor trait. When a message is sent to MyActor , it is scheduled by the system for immediate execution. The recv function is invoked and the message is printed to stdout.","title":"Defining Actors"},{"location":"actors.html#creating-actors","text":"Every application has an ActorSystem . The actor system provides actor management and the runtime to execute actors when they're sent messages. It also provides essential services such as starting actors and exposing system services. To start the actor system: use actors_rs :: * ; fn main () { let sys = ActorSystem :: new (). unwrap (); } Here we see that the actor is started using ActorSystem::new . Once we've started the actor system we're ready to create some actors. We can also configure the system with a custom name using the SystemBuilder : use actors_rs :: * ; fn main () { let sys = SystemBuilder :: new () . name ( \"my-app\" ) . create () . unwrap (); } Once the actor system is started, we can begin to create actors: use actors_rs :: * ; #[derive(Default)] struct MyActor ; impl Actor for MyActor { type Msg = String ; fn recv ( & mut self , _ctx : & Context < String > , msg : String , _sender : Sender ) { println ! ( \"received {}\" , msg ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let my_actor = sys . actor_of :: < MyActor > ( \"my-actor\" ). unwrap (); } actor_of used to create an instance of the actor. A my-actor name is also required so that we can look it up later if we need. Although this is just two lines of code, a lot is happening behind the scenes. Actor lifecycles and state are managed by the system. When an actor starts, it keeps the properties in case it needs it again to restart the actor if it fails. When an actor is created, it gets its own mailbox for receiving messages and other interested actors are notified about the new actor joining the system.","title":"Creating Actors"},{"location":"actors.html#actor-references","text":"When an actor is started using actor_of , the system returns a reference to the actor, an ActorRef . The actual actor instance remains inaccessible directly, its lifecycle being managed and protected by the system. In Rust terms, the system has and always maintains 'ownership' of the actor instance. When you're interacting with actors, you're actually interacting with the actor's ActorRef ! This is a core concept of the actor model. An ActorRef always refers to a specific instance of an actor. When two instances of the same Actor are started, they're still considered separate actors, each with different ActorRef s. ActorRef s are inexpensive and can be cloned (they implement Clone ) without too much concern about resources. References can also be used in Props as a field in another actor's factory method, a pattern known as endowment. ActorRef s can be sent as a message to another actor, a pattern known as introduction. TODO: put example here","title":"Actor References"},{"location":"actors.html#sending-messages","text":"Actors communicate only through sending and receiving messages. They are isolated and never expose their state or behavior. If we want to send a message to an actor, we use the tell method on the actor's ActorRef : basic.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Default)] struct MyActor ; // implement the Actor trait impl Actor for MyActor { type Msg = String ; fn recv ( & mut self , _ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Sender ) { println ! ( \"Received: {}\" , msg ); } } // start the system and create an actor fn main () { let sys = ActorSystem :: new (). unwrap (); let my_actor = sys . actor_of :: < MyActor > ( \"my-actor\" ). unwrap (); my_actor . tell ( \"Hello my actor!\" . to_string (), None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); } Here, we've sent a message of type String to our MyActor actor. The second parameter lets us specify a sender as an Option<BasicActorRef> (type alias Sender ). Since we're sending the message from main and not from an actor, we're setting the sender as None .","title":"Sending Messages"},{"location":"actors.html#message-guarantees","text":"Riker provides certain guarantees when handling messages: Message delivery is 'at-most-once'. A message will either fail to be delivered, or be delivered one time. There is no repeat delivery of the same message. An actor handles one message at any time. Messages are stored in an actor's mailbox in the order that they are received. On this page, you learned the basics of creating a Riker application using actors. Let's move on to the next section to see more comprehensive example using multiple message types: Sending multiple message types","title":"Message Guarantees"},{"location":"channels.html","text":"Channels Riker channels allow for messages to be published to interested subscribers. Channels are actors so messaging a channel works the same way as any othe actor. Starting a channel The riker::actors::channel function returns a channel: let chan : ChannelRef < PowerStatus > = channel ( \"power-status\" , & sys ). unwrap (); Subscribing To subscribe to and receive messages from a channel an actor must support the message type of the channel. In the above example we created a channel that publishes PowerStatus messages, notifying components in an autonomous vehicle of changes in available battery energy. Let's create two actors that will subscribe to the channel so they can receive this message: #[actor(PowerStatus)] struct GpsActor ; #[actor(Power)] struct NavigationActor ; .. . // Each actor would send a Subscribe message to the // channel, typically in `pre_start`. E.g.: let sub = Box :: new ( ctx . myself ()); chan . tell ( Subscribe { actor : sub , topic : \"*\" . into () }, None ); Here we have two actors that each need to receive status changes in available battery power so they can adapt their behavior. They both must support the PowerStatus message that the channel publishes. You'll notice that we need to use Box to create a trait object of Tell<PowerStatus> . The Subscribe message is used to subscribe an actor to a channel, which you'll notice requires a topic. A channel consists of one or more topics, typically that have a common theme. When a message is published it is published to a specific topic on the channel. Note When subscribing to a topic, if it does't already exist it will be created and any future messages published to it will be sent to the subscriber. Publishing The Publish message is used to publish to a channel: let stat = PowerStatus { .. . }; chan . tell ( Publish { msg : stat , topic : \"power\" . into () }, None ); This message will be cloned and sent to each subscriber of my-topic on the channel chan . In this case, it may be that the GpsActor will choose to lower the GPS sampling rate if the battery level falls below a certain percentage, thus lowering the power used. The NavigationActor might override any active mission and force the vehicle to return to base if the power level drops to a critical level. The same use of channels could be applied to ecommerce platforms, payments systems, warehouse logistics, shipping tracking, etc. Common channels When the actor system starts serveral channels are created. These channels help developers receive messages about system events and failed messages. System events The System Events channel provides events including ActorCreated , ActorRestarted and ActorTerminated events. Each of these are reprented as topic actor.created , actor.restarted and actor.terminated topics respectively. The message type is SystemEvent enum Example: sys . sys_events () . tell ( Subscribe { actor : sub1 , topic : \"actor.created\" . into () }, None ); Note System events are considered system messages and therefore a subscriber's Actor::sys_recv method will be invoked instead of Actor::recv . Dead letters The Dead Letters channel publishes messages that failed to be delivered to their destination actor. This channel can be subscribed to to handle those messages. Note: Dead letters use Debug representation of the original undelivered message, limiting the use of dead letters to logging of failed messages rather than actually acting upon them. Example: sys . dead_letters (). tell ( Subscribe { actor : sub1 , topic : \"*\" . into () }, None ); Channels form an integral part of the Riker system and provide essential services to creating dynamic applications where actors collaborate to achieve a common goal. Next we'll look at scheduling messages to be sent at a time in the future. Scheduling Messages","title":"Channels"},{"location":"channels.html#channels","text":"Riker channels allow for messages to be published to interested subscribers. Channels are actors so messaging a channel works the same way as any othe actor.","title":"Channels"},{"location":"channels.html#starting-a-channel","text":"The riker::actors::channel function returns a channel: let chan : ChannelRef < PowerStatus > = channel ( \"power-status\" , & sys ). unwrap ();","title":"Starting a channel"},{"location":"channels.html#subscribing","text":"To subscribe to and receive messages from a channel an actor must support the message type of the channel. In the above example we created a channel that publishes PowerStatus messages, notifying components in an autonomous vehicle of changes in available battery energy. Let's create two actors that will subscribe to the channel so they can receive this message: #[actor(PowerStatus)] struct GpsActor ; #[actor(Power)] struct NavigationActor ; .. . // Each actor would send a Subscribe message to the // channel, typically in `pre_start`. E.g.: let sub = Box :: new ( ctx . myself ()); chan . tell ( Subscribe { actor : sub , topic : \"*\" . into () }, None ); Here we have two actors that each need to receive status changes in available battery power so they can adapt their behavior. They both must support the PowerStatus message that the channel publishes. You'll notice that we need to use Box to create a trait object of Tell<PowerStatus> . The Subscribe message is used to subscribe an actor to a channel, which you'll notice requires a topic. A channel consists of one or more topics, typically that have a common theme. When a message is published it is published to a specific topic on the channel. Note When subscribing to a topic, if it does't already exist it will be created and any future messages published to it will be sent to the subscriber.","title":"Subscribing"},{"location":"channels.html#publishing","text":"The Publish message is used to publish to a channel: let stat = PowerStatus { .. . }; chan . tell ( Publish { msg : stat , topic : \"power\" . into () }, None ); This message will be cloned and sent to each subscriber of my-topic on the channel chan . In this case, it may be that the GpsActor will choose to lower the GPS sampling rate if the battery level falls below a certain percentage, thus lowering the power used. The NavigationActor might override any active mission and force the vehicle to return to base if the power level drops to a critical level. The same use of channels could be applied to ecommerce platforms, payments systems, warehouse logistics, shipping tracking, etc.","title":"Publishing"},{"location":"channels.html#common-channels","text":"When the actor system starts serveral channels are created. These channels help developers receive messages about system events and failed messages.","title":"Common channels"},{"location":"channels.html#system-events","text":"The System Events channel provides events including ActorCreated , ActorRestarted and ActorTerminated events. Each of these are reprented as topic actor.created , actor.restarted and actor.terminated topics respectively. The message type is SystemEvent enum Example: sys . sys_events () . tell ( Subscribe { actor : sub1 , topic : \"actor.created\" . into () }, None ); Note System events are considered system messages and therefore a subscriber's Actor::sys_recv method will be invoked instead of Actor::recv .","title":"System events"},{"location":"channels.html#dead-letters","text":"The Dead Letters channel publishes messages that failed to be delivered to their destination actor. This channel can be subscribed to to handle those messages. Note: Dead letters use Debug representation of the original undelivered message, limiting the use of dead letters to logging of failed messages rather than actually acting upon them. Example: sys . dead_letters (). tell ( Subscribe { actor : sub1 , topic : \"*\" . into () }, None ); Channels form an integral part of the Riker system and provide essential services to creating dynamic applications where actors collaborate to achieve a common goal. Next we'll look at scheduling messages to be sent at a time in the future. Scheduling Messages","title":"Dead letters"},{"location":"cluster.html","text":"Clustering Placeholder page for clustering systems. Enable Clustering Gossip Protocol Distributing Data Using CRDTs","title":"Clustering"},{"location":"cluster.html#clustering","text":"Placeholder page for clustering systems.","title":"Clustering"},{"location":"cluster.html#enable-clustering","text":"","title":"Enable Clustering"},{"location":"cluster.html#gossip-protocol","text":"","title":"Gossip Protocol"},{"location":"cluster.html#distributing-data-using-crdts","text":"","title":"Distributing Data Using CRDTs"},{"location":"config.html","text":"Configuration Basics Riker makes configuration straightforward by using two config files: riker.toml can be modified to change the behavior of Riker and various modules app.* , such as app.toml or app.yml for application specific settings Configuration is based on the Config crate meaning that any format supported by that crate can be used for application setting. When the system starts riker.toml is loaded and if an application config file exists it will be merged into a single Config instance. This keeps settings separate for the purposes of maintenance and CI/CD, but makes it uniformly available at runtime. The Config instance is accessible via the ActorSystem instance, for example: let myval = sys . config (). get_str ( \"app.myval\" ). unwrap (); This expects the following entry in app.* : [app] myval = \"five by five\" File Paths By default Riker looks for riker.toml and app.* in the config directory relative to the current directory of execution. It's standard practice to place the config directory in the root directory of your Rust application, i.e. on the same level as src . This way, cargo run and cargo test will use the files located in config . Configuration file paths can be overridden using environment variables: RIKER_CONF to override riker.toml file path APP_CONF to override app.* file path Best Practises Default Values Default values are discouraged. If a setting is missing from a config file it's better to let .unwrap() panic than to use a hidden default settings in code. This makes it clear as to what settings are being used and there is no unexpected behavior at runtime. It's better to not run at all than run with bad, possibly dangerous settings. Using .config() It is highly encouraged in terms of function signatures to not pass around instances of Config . Not only is it slower but it makes understanding what a function does difficult. It is always better to extract values from configuration early on in your application and then pass those to functions. If you have many settings to pass to a function a dedicated settings struct could be used. Module Settings It is encouraged to reuse the standard section names for modules. For example, if you have a custom logging module then use [log] in riker.toml . This makes it easier for people to locate these settings based on module behavior. Example [persistence] redis_url = \"tcp://127.0.0.1\" resis_pwd = \"password123\" Or [persistence] redis = { url = \"tcp://127.0.0.1\" , pwd = \"password123\" }","title":"Configuration"},{"location":"config.html#configuration","text":"","title":"Configuration"},{"location":"config.html#basics","text":"Riker makes configuration straightforward by using two config files: riker.toml can be modified to change the behavior of Riker and various modules app.* , such as app.toml or app.yml for application specific settings Configuration is based on the Config crate meaning that any format supported by that crate can be used for application setting. When the system starts riker.toml is loaded and if an application config file exists it will be merged into a single Config instance. This keeps settings separate for the purposes of maintenance and CI/CD, but makes it uniformly available at runtime. The Config instance is accessible via the ActorSystem instance, for example: let myval = sys . config (). get_str ( \"app.myval\" ). unwrap (); This expects the following entry in app.* : [app] myval = \"five by five\"","title":"Basics"},{"location":"config.html#file-paths","text":"By default Riker looks for riker.toml and app.* in the config directory relative to the current directory of execution. It's standard practice to place the config directory in the root directory of your Rust application, i.e. on the same level as src . This way, cargo run and cargo test will use the files located in config . Configuration file paths can be overridden using environment variables: RIKER_CONF to override riker.toml file path APP_CONF to override app.* file path","title":"File Paths"},{"location":"config.html#best-practises","text":"","title":"Best Practises"},{"location":"config.html#default-values","text":"Default values are discouraged. If a setting is missing from a config file it's better to let .unwrap() panic than to use a hidden default settings in code. This makes it clear as to what settings are being used and there is no unexpected behavior at runtime. It's better to not run at all than run with bad, possibly dangerous settings.","title":"Default Values"},{"location":"config.html#using-config","text":"It is highly encouraged in terms of function signatures to not pass around instances of Config . Not only is it slower but it makes understanding what a function does difficult. It is always better to extract values from configuration early on in your application and then pass those to functions. If you have many settings to pass to a function a dedicated settings struct could be used.","title":"Using .config()"},{"location":"config.html#module-settings","text":"It is encouraged to reuse the standard section names for modules. For example, if you have a custom logging module then use [log] in riker.toml . This makes it easier for people to locate these settings based on module behavior. Example [persistence] redis_url = \"tcp://127.0.0.1\" resis_pwd = \"password123\" Or [persistence] redis = { url = \"tcp://127.0.0.1\" , pwd = \"password123\" }","title":"Module Settings"},{"location":"faq.html","text":"What is Riker's goal? Riker's principle goal is to be a framework to make concurrent, resilient software development easy and to make the Actor Model applicable to a wide spectrum of platforms. Riker achieves this by: Exposing a simple Actor trait Actor supervision based on the actor hierarchy Allowing Actors to own their state so Sync is not required Ensuring an 'at most one-time' message guarantee Providing a configurable, modular system Promotion of modern, event-based data persistence Low memory footprint Fast execution No unsafe code (with the exception of impl Send and impl Sync ) Is Riker a remake of Akka for Rust? Riker is inspired by Akka , the JVM's popular Actor Model implementation. However it's not Riker's goal to recreate Akka for Rust. Other environments have done this, for example C#'s Akka.NET but the differences of Rust and Scala/Java and others require a fresh Rust-specific approach. And since Riker works well on resource limited hardware such as single board computers there are new challenges and problems to solve that are not applicable to Akka. How do actors compare to Futures? Both Actors and Futures in general work to solve the challenges of concurrent software design. However they are complimentary since they are solving different issues. Futures allow software developers to write concurrent code in an almost single-threaded manner. Simple, short-lived workload processing that is non-blocking can be easily written. So Futures can be seen as building blocks for non-blocking application design. Actors on the other hand are used when state exists and must be maintained between cycles of when an actor is running and when it is idle. Actors are well suited for long running processes that can even span the lifetime of the application itself. Actors also form a hierarchy, with parent and child actors, which communicate with each other via a message based API. Since Actors are aware of other Actors in the system they can heal each other when unexpected things happen, such as panics. Under the covers, Riker actors are Futures and run as Futures on the underlying thread pool. How do actors compare to threads? Actors only run and use a CPU thread when they have one or more messages in their mailbox. When an actor is sent a message that actor is scheduled for execution. When a thread is available the actor and its state are transferred (i.e. Send ) to the thread and the actor processes its messages (i.e. the receive method is invoked). It is only then that the actor will use any OS thread resources. When an actor is idle it requires no thread execution time. It's possible to have thousands or millions of actors that share just two CPU core/threads. Can Riker run on muliple hosts? Like any application a Riker application can easily be distributed across multiple network hosts or Docker containers. Applications can be load balanced using simple load balancing or form part of a more complex system using a Kubernetes , Linkerd , etc. It is only when an an application uses Riker's CQRS features should additional architecture design be considered to manage entities. In a CQRS environment it is critical to ensure that only one instance of an entity actor be running across multiple hosts. Riker Cluster is currently in development to make this coordination available. Can multiple ActorSystem instances run in the same app? It is possible to create two or more instances using ActorSystem::new but there is little benefit in doing so. A single instance is already optimized to run actors on the configured dispatcher which generally uses all cores of a CPU. An exception to this advice is when an application is handling greatly varying workloads and it is not possible due to architecture constraints to break into multiple applications. Does Riker use unsafe code? Riker does not use unsafe for any memory management. We believe it's better to work with the Borrow Checker and compiler than against them. unsafe is only used to explicitly mark a few types as Send or Sync to assist the compiler. Both of these have empty implementations, i.e. no actual unsafe code: unsafe impl<T: Message> Send for Envelope<T> {} Are there any benchmarks? We're working to provide common actor benchmarks soon. We want to make sure we're using benchmarks that actually mean something to real world scenarios. In terms of pure message throughput, one actor to another, several million messages can be sent per second on a standard 2018 laptop.","title":"FAQ"},{"location":"futures.html","text":"Running Futures Riker can execute and drive futures to completion. In fact, internally actors are executed as futures by the dispatcher. This means Riker can run any future on the same executor, alongside actors. ActorSystem and Context both have a run method that takes a future to run: let handle = system . run ( async move { \"someval\" . to_string () }); assert_eq ! ( block_on ( handle ), \"someval\" . to_string ()); sys.run schedules the future for execution it will drive it to completion utilizing the dispatcher's thread pool. run returns a futures::future::RemoteHandle future that can be used to extract the result. Note Riker executes futures using the Futures crate's futures::executor::ThreadPool . In the next section we'll see how to to test Riker applications. Testing","title":"Running Futures"},{"location":"futures.html#running-futures","text":"Riker can execute and drive futures to completion. In fact, internally actors are executed as futures by the dispatcher. This means Riker can run any future on the same executor, alongside actors. ActorSystem and Context both have a run method that takes a future to run: let handle = system . run ( async move { \"someval\" . to_string () }); assert_eq ! ( block_on ( handle ), \"someval\" . to_string ()); sys.run schedules the future for execution it will drive it to completion utilizing the dispatcher's thread pool. run returns a futures::future::RemoteHandle future that can be used to extract the result. Note Riker executes futures using the Futures crate's futures::executor::ThreadPool . In the next section we'll see how to to test Riker applications. Testing","title":"Running Futures"},{"location":"hierarchy.html","text":"Actor Hierarchy Actors in Riker form a hierarchy with each actor addressable by a path. An actor's place in the hierarchy is determined by the location of its parent. Let's take a look at what the actor hierarchy looks like immediately after the actor system has started: riker \u2514\u2500 user \u2514\u2500 system \u2514\u2500 logger \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp We can see that without starting any actors ourselves, there's already a number of actors running. At the base of the hierarchy is our application which by default is named riker unless a name was provided using SystemBuilder . There's then three root actors, user , system and temp . These are guardian actors under which all other actors are created. Perhaps the most important of these is user , since most actors created as part of the application are created in this branch. If we start an actor using system.actor_of::<MyActor>(\"my-actor\") we can see it added under user : my-app \u2514\u2500 user \u2514\u2500 my-actor <-- our new actor is added \u2514\u2500 system \u2514\u2500 logger \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp In this case the newly created my-actor has a path of /user/my-actor . Since it was started by using actor_of on ActorSystem it is considered a top-level actor. Let's look at how the hierarchy changes when another actor is started, this time from within /user/my-actor 's recv method using Context.actor_of . hierarchy.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Default)] struct Child ; impl Actor for Child { type Msg = String ; fn recv ( & mut self , _ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Sender ) { println ! ( \"child got a message {}\" , msg ); } } #[derive(Default)] struct MyActor { child : Option < ActorRef < String >> , } // implement the Actor trait impl Actor for MyActor { type Msg = String ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . child = Some ( ctx . actor_of :: < Child > ( \"my-child\" ). unwrap ()); } fn recv ( & mut self , _ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { println ! ( \"parent got a message {}\" , msg ); self . child . as_ref (). unwrap (). tell ( msg , sender ); } } // start the system and create an actor fn main () { let sys = ActorSystem :: new (). unwrap (); let my_actor = sys . actor_of :: < MyActor > ( \"my-actor\" ). unwrap (); my_actor . tell ( \"Hello my actor!\" . to_string (), None ); println ! ( \"Child not added yet\" ); sys . print_tree (); println ! ( \"Child added already\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); } Here MyActor will start another actor, which is also an instance of MyActor . my-app \u2514\u2500 user \u2514\u2500 my-actor \u2514\u2500 my-child <-- our new actor is added \u2514\u2500 system \u2514\u2500 logger \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp Since the new actor was started using my-actor 's context it is added to the hierarchy as a child of my-actor . my-child 's path becomes /user/my-actor/my-child . Let's move on the next section where we'll look at how the actor hierarchy is used in supervision to build resilient, self healing applications. Fault Tolerance","title":"Actor Hierarchy"},{"location":"hierarchy.html#actor-hierarchy","text":"Actors in Riker form a hierarchy with each actor addressable by a path. An actor's place in the hierarchy is determined by the location of its parent. Let's take a look at what the actor hierarchy looks like immediately after the actor system has started: riker \u2514\u2500 user \u2514\u2500 system \u2514\u2500 logger \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp We can see that without starting any actors ourselves, there's already a number of actors running. At the base of the hierarchy is our application which by default is named riker unless a name was provided using SystemBuilder . There's then three root actors, user , system and temp . These are guardian actors under which all other actors are created. Perhaps the most important of these is user , since most actors created as part of the application are created in this branch. If we start an actor using system.actor_of::<MyActor>(\"my-actor\") we can see it added under user : my-app \u2514\u2500 user \u2514\u2500 my-actor <-- our new actor is added \u2514\u2500 system \u2514\u2500 logger \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp In this case the newly created my-actor has a path of /user/my-actor . Since it was started by using actor_of on ActorSystem it is considered a top-level actor. Let's look at how the hierarchy changes when another actor is started, this time from within /user/my-actor 's recv method using Context.actor_of . hierarchy.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Default)] struct Child ; impl Actor for Child { type Msg = String ; fn recv ( & mut self , _ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Sender ) { println ! ( \"child got a message {}\" , msg ); } } #[derive(Default)] struct MyActor { child : Option < ActorRef < String >> , } // implement the Actor trait impl Actor for MyActor { type Msg = String ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . child = Some ( ctx . actor_of :: < Child > ( \"my-child\" ). unwrap ()); } fn recv ( & mut self , _ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { println ! ( \"parent got a message {}\" , msg ); self . child . as_ref (). unwrap (). tell ( msg , sender ); } } // start the system and create an actor fn main () { let sys = ActorSystem :: new (). unwrap (); let my_actor = sys . actor_of :: < MyActor > ( \"my-actor\" ). unwrap (); my_actor . tell ( \"Hello my actor!\" . to_string (), None ); println ! ( \"Child not added yet\" ); sys . print_tree (); println ! ( \"Child added already\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); } Here MyActor will start another actor, which is also an instance of MyActor . my-app \u2514\u2500 user \u2514\u2500 my-actor \u2514\u2500 my-child <-- our new actor is added \u2514\u2500 system \u2514\u2500 logger \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp Since the new actor was started using my-actor 's context it is added to the hierarchy as a child of my-actor . my-child 's path becomes /user/my-actor/my-child . Let's move on the next section where we'll look at how the actor hierarchy is used in supervision to build resilient, self healing applications. Fault Tolerance","title":"Actor Hierarchy"},{"location":"io.html","text":"","title":"Io"},{"location":"logging.html","text":"Logging Riker provides logging out of the box which is built on top of the Log crate logging facade. The logger module starts during the actor system's start, making log macros such as info! , debug! , error! available immediately after ActorSystem::new : #[macro_use] extern crate log ; let sys = ActorSystem :: new (). unwrap (); info ! ( \"My first log message!\" ); The only requirement is importing the Log crate into your application. Base log level The base log level is the level at which the Log crate's macros determine whether to ignore a message or forward it to the logger module. This is configured in riker.toml : [log] level = \"debug\" Default logger Log messages will be routed to the logging module configured in the model. The rest of this page refers primarily to the default Riker logger, the riker-logger crate. Since the default logger is an actor log messages are handled concurrently, in a non-blocking manner. This means the impact of logging on an application's response time is reduced. The default logger has the following features: Log entry format is configurable using named parameters Date and time formats can be configured Log entries can be further filtered at the module level An optional filter can be configured to omit logs from certain modules Let's take a look at an example log configuration in riker.toml : [log] # max level to log level = \"debug\" # Uncomment this to enable filters on the logger. The {module} field # of every log line will be checked, and if the {module} field contains # any item in this list, the entire log line will be omitted from the # logging output. # # This example will omit any logging output from any module with # \"test\" in the name and any module whose name contains \"debug\". # filter = [ \"test\", \"debug\" ] # log format to use # correlates to format!(log_format, date=, time=, level=, module=, body=); # since named parameters are used the order of the fields is flexible # the formatting of each field can be changed also # e.g. to completely hide a field: {module:.0} # See: https://doc.rust-lang.org/std/fmt/#syntax # {date} the calendar day # {time} the calendar time # {level} the level for the entry # {module} the module path originating the entry # {body} the message body log_format = \"{date} {time} {level} [{module}] {body}\" date_format = \"%Y-%m-%d\" time_format = \"%H:%M:%S%:z\" This configuration will produce log entries formatted like: 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ riker::system::system ] Actor system started 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ main ] My first log message ! and the log lines which would have otherwise been printed: 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ testSystem ] A test line which should be filtered out ! 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ debug ] A debugger module ' s log message will be omitted from the log output.","title":"Logging"},{"location":"logging.html#logging","text":"Riker provides logging out of the box which is built on top of the Log crate logging facade. The logger module starts during the actor system's start, making log macros such as info! , debug! , error! available immediately after ActorSystem::new : #[macro_use] extern crate log ; let sys = ActorSystem :: new (). unwrap (); info ! ( \"My first log message!\" ); The only requirement is importing the Log crate into your application.","title":"Logging"},{"location":"logging.html#base-log-level","text":"The base log level is the level at which the Log crate's macros determine whether to ignore a message or forward it to the logger module. This is configured in riker.toml : [log] level = \"debug\"","title":"Base log level"},{"location":"logging.html#default-logger","text":"Log messages will be routed to the logging module configured in the model. The rest of this page refers primarily to the default Riker logger, the riker-logger crate. Since the default logger is an actor log messages are handled concurrently, in a non-blocking manner. This means the impact of logging on an application's response time is reduced. The default logger has the following features: Log entry format is configurable using named parameters Date and time formats can be configured Log entries can be further filtered at the module level An optional filter can be configured to omit logs from certain modules Let's take a look at an example log configuration in riker.toml : [log] # max level to log level = \"debug\" # Uncomment this to enable filters on the logger. The {module} field # of every log line will be checked, and if the {module} field contains # any item in this list, the entire log line will be omitted from the # logging output. # # This example will omit any logging output from any module with # \"test\" in the name and any module whose name contains \"debug\". # filter = [ \"test\", \"debug\" ] # log format to use # correlates to format!(log_format, date=, time=, level=, module=, body=); # since named parameters are used the order of the fields is flexible # the formatting of each field can be changed also # e.g. to completely hide a field: {module:.0} # See: https://doc.rust-lang.org/std/fmt/#syntax # {date} the calendar day # {time} the calendar time # {level} the level for the entry # {module} the module path originating the entry # {body} the message body log_format = \"{date} {time} {level} [{module}] {body}\" date_format = \"%Y-%m-%d\" time_format = \"%H:%M:%S%:z\" This configuration will produce log entries formatted like: 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ riker::system::system ] Actor system started 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ main ] My first log message ! and the log lines which would have otherwise been printed: 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ testSystem ] A test line which should be filtered out ! 2018 - 06 - 11 08 : 31 : 58 + 00 : 00 DEBUG [ debug ] A debugger module ' s log message will be omitted from the log output.","title":"Default logger"},{"location":"messaging.html","text":"Multi-type Messaging In real world applications, actors will typically receive different message types and execute different behaviors based on the type received. So far you've seen a simple example where an actor's message type is defined in the Actor::Msg associated type. More specifically, this defines an actor's mailbox type. To allow an actor to receive multiple message types, Riker provides a Receive<T> trait and the #[actor] attribute. Let's see how these are used: messaging.rs use actors_rs :: * ; use std :: time :: Duration ; // Define the messages we'll use #[derive(Clone, Debug)] pub struct Add ; #[derive(Clone, Debug)] pub struct Sub ; #[derive(Clone, Debug)] pub struct Print ; // Define the Actor and use the 'actor' attribute // to specify which messages it will receive #[actor(Add, Sub, Print)] struct Counter { count : u32 , } impl ActorFactoryArgs < u32 > for Counter { fn create_args ( count : u32 ) -> Self { Self { count } } } impl Actor for Counter { // we used the #[actor] attribute so CounterMsg is the Msg type type Msg = CounterMsg ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { // Use the respective Receive<T> implementation self . receive ( ctx , msg , sender ); } } impl Receive < Add > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Add , _sender : Sender ) { self . count += 1 ; } } impl Receive < Sub > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Sub , _sender : Sender ) { self . count -= 1 ; } } impl Receive < Print > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Print , _sender : Sender ) { println ! ( \"Total counter value: {}\" , self . count ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let actor = sys . actor_of_args :: < Counter , _ > ( \"counter\" , 0 ). unwrap (); actor . tell ( Add , None ); actor . tell ( Add , None ); actor . tell ( Sub , None ); actor . tell ( Print , None ); sys . print_tree (); // force main to wait before exiting program std :: thread :: sleep ( Duration :: from_millis ( 500 )); } In this example, we've used #actor[Add, Sub, Print] to set up the actor to receive Add , Sub and Print types. For each of these, the Receive<T> trait is implemented on the actor, defining how each message should be handled. Note When using the #[actor()] attribute, the actor's Msg associated type should be set to '[DataType]Msg'. E.g. if an actor is a struct named MyActor , then the Actor::Msg associated type will be MyActorMsg . By utilizing Receive<T> and #[actor] , complex message handling can be defined clearly and concisely. TODO: For more advanced messaging examples see Advanced Messaging . In the next section, we'll explore the relationship between actors and how actors form a hierarchy. Actor Hierarchy","title":"Message Types"},{"location":"messaging.html#multi-type-messaging","text":"In real world applications, actors will typically receive different message types and execute different behaviors based on the type received. So far you've seen a simple example where an actor's message type is defined in the Actor::Msg associated type. More specifically, this defines an actor's mailbox type. To allow an actor to receive multiple message types, Riker provides a Receive<T> trait and the #[actor] attribute. Let's see how these are used: messaging.rs use actors_rs :: * ; use std :: time :: Duration ; // Define the messages we'll use #[derive(Clone, Debug)] pub struct Add ; #[derive(Clone, Debug)] pub struct Sub ; #[derive(Clone, Debug)] pub struct Print ; // Define the Actor and use the 'actor' attribute // to specify which messages it will receive #[actor(Add, Sub, Print)] struct Counter { count : u32 , } impl ActorFactoryArgs < u32 > for Counter { fn create_args ( count : u32 ) -> Self { Self { count } } } impl Actor for Counter { // we used the #[actor] attribute so CounterMsg is the Msg type type Msg = CounterMsg ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { // Use the respective Receive<T> implementation self . receive ( ctx , msg , sender ); } } impl Receive < Add > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Add , _sender : Sender ) { self . count += 1 ; } } impl Receive < Sub > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Sub , _sender : Sender ) { self . count -= 1 ; } } impl Receive < Print > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Print , _sender : Sender ) { println ! ( \"Total counter value: {}\" , self . count ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let actor = sys . actor_of_args :: < Counter , _ > ( \"counter\" , 0 ). unwrap (); actor . tell ( Add , None ); actor . tell ( Add , None ); actor . tell ( Sub , None ); actor . tell ( Print , None ); sys . print_tree (); // force main to wait before exiting program std :: thread :: sleep ( Duration :: from_millis ( 500 )); } In this example, we've used #actor[Add, Sub, Print] to set up the actor to receive Add , Sub and Print types. For each of these, the Receive<T> trait is implemented on the actor, defining how each message should be handled. Note When using the #[actor()] attribute, the actor's Msg associated type should be set to '[DataType]Msg'. E.g. if an actor is a struct named MyActor , then the Actor::Msg associated type will be MyActorMsg . By utilizing Receive<T> and #[actor] , complex message handling can be defined clearly and concisely. TODO: For more advanced messaging examples see Advanced Messaging . In the next section, we'll explore the relationship between actors and how actors form a hierarchy. Actor Hierarchy","title":"Multi-type Messaging"},{"location":"patterns.html","text":"Patterns Ask The Ask pattern allows values to be sent by actors to outside of the actor system. The value is delivered as a Future . Let's look at how this works: use riker_patterns :: ask ; struct MyActor ; impl Actor for MyActor { type Msg = u32 ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { // sender is the Ask, waiting for a message to be sent back to it sender . as_ref () . unwrap () . try_tell ( msg * 2 , Some ( ctx . myself (). into ())); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let props = MyActor :: props (); let my_actor = sys . actor_of ( props , \"my-actor\" ); // ask returns a future that automatically is driven // to completion by the system. let res : RemoteHandle < String > = ask ( & sys , & my_actor , 100 ); // the result future can be passed to a library or fuction that // expects a future, or it can be extracted locally using `block_on`. let res = block_on ( res ); println ! ( \"The result value is: {}\" , res ); } In the background Ask sets up a temporary intermediate actor that lives for the lifetime of the ask. Other actors see this temporary actor as the sender and can send a message back to it. When the temporary ask actor receives a message it fulfills the outstanding future and performs a stop on itself to cleanup. Ask is particularly useful when you have part of an application that runs outside of the actor system, or in another actor system, such as a web server (e.g. Hyper) serving API requests. The resulting future can then be chained as part of the future stack.","title":"Patterns"},{"location":"patterns.html#patterns","text":"","title":"Patterns"},{"location":"patterns.html#ask","text":"The Ask pattern allows values to be sent by actors to outside of the actor system. The value is delivered as a Future . Let's look at how this works: use riker_patterns :: ask ; struct MyActor ; impl Actor for MyActor { type Msg = u32 ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { // sender is the Ask, waiting for a message to be sent back to it sender . as_ref () . unwrap () . try_tell ( msg * 2 , Some ( ctx . myself (). into ())); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let props = MyActor :: props (); let my_actor = sys . actor_of ( props , \"my-actor\" ); // ask returns a future that automatically is driven // to completion by the system. let res : RemoteHandle < String > = ask ( & sys , & my_actor , 100 ); // the result future can be passed to a library or fuction that // expects a future, or it can be extracted locally using `block_on`. let res = block_on ( res ); println ! ( \"The result value is: {}\" , res ); } In the background Ask sets up a temporary intermediate actor that lives for the lifetime of the ask. Other actors see this temporary actor as the sender and can send a message back to it. When the temporary ask actor receives a message it fulfills the outstanding future and performs a stop on itself to cleanup. Ask is particularly useful when you have part of an application that runs outside of the actor system, or in another actor system, such as a web server (e.g. Hyper) serving API requests. The resulting future can then be chained as part of the future stack.","title":"Ask"},{"location":"persistence.html","text":"Persisting State Riker supports persistence so that actors can restore their state when they are restarted. Riker takes an event sourcing approach to persisting data, whereby only changes to state and not the entire current state are persisted. These changes to an actor's state are considered events and are appended to the underlying event store. Actors that persist their state are often referred to as Persistent Actors. Event Sourcing When a persistent actor restarts its state can be restored by replaying all events in the event store, specific to the actor, in the order in which they we're originally persisted. Event sourcing has several advantages over traditional data persistence methods. Since a persistent actor maintains its state in memory it's not necessary to continually read data from storage. Events are only read from the underlying storage when an actor starts. This allows for extremely high transaction rates. Event sourcing simplifies data storage since events are typically serialized objects that can be persisted to a single column or field in a database. Other non-database storage methods can also be leveraged, such as persistent queues or transaction logs. The complexities of data querying, such as database schema design and indexes aren't pertinent to event sourcing. In addition, since data structure is simplified migration between data storage solutions is made easier. An additional added value is that you get inherent auditing through the immutable nature of event sourcing - every event is recorded and remains in perpetuity. Enabling Persistence An actor can be configured to persist state, i.e. be a persistent actor by returning a PersistenceConf on the persistence_conf method of the Actor trait: struct MyActor { id : String , val : u32 , } fn persistence_conf ( & self ) -> Option < PersistenceConf > { let conf = PersistenceConf { id : self . id . clone (), keyspace : \"my-actor\" . to_string () }; Some ( conf ) } The combiniation of id and keyspace allow the underlying event storage to separate events so that when an actor re/starts only the events for that actor are queried. How these fields are used depends exclusively on the event store module used. Warning Events must be specific to an actual actor instance. Load balancing two actors representing the same logical entity, for example a specific user, will conflict since only the actor handling the event will update its state. Persisting Events A persistent actor uses the ctx.persist_event method to actually persist state. Like all other Actor operations in Riker this is a non-blocking operation: fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Option < ActorRef < Self :: Msg >> ) { ctx . persist_event ( msg ); // <-- schedule event to be persisted } Here we see that ctx.persist_event is used to request the event to be stored. In this case we're using the message received as the event, but this could be any rust type that is part of your configured protocol. There are two important concepts to highlight at this point: persist_event is a non-blocking operation and execution will continue There are no guarantees that the event will be successfully stored Since these two factors hold it is important to refrain from making any state change until it is known that the event has been successfully written to the event store. The event store is responsible for signaling back to the actor when an event has been successfully committed to storage. When ctx.persist_event is invoked a persistent actor enters a 'persisting' state. During this state no further messages will be handled by the actor until the event store signals back that the event was successfully stored. This occurs to provide a guarantee that when the next message to be handled by receive the actor has the latest state. An actor's apply_event method is invoked when an event is successfully stored: fn apply_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val = evt ; // <-- safe to update the state // Its also safe to create side effects here // e.g. // `some_actor.tell(\"your support request was received\", None);` } It's here in apply_event that state can be safely mutated, since any failure at this stage means that the event will be replayed when the actor restarts. Warning Never make state changes in receive of a persistent actor. Replaying Events When a persistent actor starts its events are queried based on the configured id and keyspace . It is guaranteed that no messages will be handled by receive until the persistent actor finishes replaying all events. The query to load events is a non-blocking operation. Once all events have been queried the replay_event method is invoked for each event: fn replay_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val += evt ; // <-- safe to update the state // It is *not* safe to create side effects in replay_event } replay_event is similar to apply_event in that state should be mutated in this method. However, there may be undesirable side effects during replay that were necessary during the initial persistence, such as sending other messages. For example, if your actor sends email messages to customers each time they make a request you don't want to send these messages each time your actor restarts. Let's see a complete example of a persistent actor: struct MyActor { id : String , val : u32 , } impl Actor for MyActor { type Msg = u32 ; fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Option < ActorRef < Self :: Msg >> ) { ctx . persist_event ( msg ); } fn persistence_conf ( & self ) -> Option < PersistenceConf > { let conf = PersistenceConf { id : self . id . clone (), keyspace : \"my-actor\" . to_string () }; Some ( conf ) } fn apply_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val += evt ; } fn replay_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val += evt ; } } Event Store In Riker events are persisted to an 'event store' configured in the model when the actor system is created. The event store is responsible for storing and loading events. To support your specific storage or database the EventStore trait can be implemented: pub trait EventStore : Clone + Send + Sync + 'static { type Msg : Message ; fn new ( config : & Config ) -> Self ; fn insert ( & mut self , id : & String , keyspace : & String , evt : Evt < Self :: Msg > ); fn load ( & self , id : & String , keyspace : & String ) -> Vec < Self :: Msg > ; } An implementation of EventStore simply needs to provide an instance of Self in the new function that will be invoked when the actor system starts. insert and load methods perform any serialization and deserialization necessary. The methods are invoked when persist_event is used and when an actor starts respectively. Note Since an event store only contains events and not whole state data can be serialized and stored in a single column of a database table for example. CBOR, JSON, MessagePack or any other serialization format could be used. The default model uses a simple in-memory event store which can be useful in tests and simple applications. All events are lost when the actor system is stopped. CQRS Command Query Responsibility Separation (CQRS) builds of top of event sourcing to provide a more structured approach to persistence. Event sourcing alone works well for restoring individual actor state in an actor system with a fixed number of actors. This could be taken further so that data entities can be modeled as actors. For example, an entity could be a User, Account, Post, Transaction, Order, etc, where every instance is represented by its own actor instance. To make changes to an entity commands are sent to the actor representing that entity. For example, to change the password of a User entity an UpdatePasswordCmd can be sent, or to disable the user a DisableUserCmd can be sent. When an actor receives a command it validates it and then emits an event that will be persisted and applied: UpdatePasswordCmd => PasswordUpdatedEvt DisableUserCmd => UserDisabledEvt To help with setting up entities and command management Riker CQRS is a separate crate ( riker-cqrs ) that introduces: Entity management Command based messaging Since each entity has its own actor there needs to be a coordinator that creates actors when needed and routes commands to the right actor. Basic bookkeeping is also required, so that actors can sleep and be removed from memory after a period of inactivity and then restored when they're needed to handle a command. Let's look at how to set up an entity manager that represents bank accounts BankAccount : use riker_cqrs :: * ; let model : DefaultModel < TestMsg > = DefaultModel :: new (); let sys = ActorSystem :: new ( & model ). unwrap (); let em = Entity :: new ( & sys , BankAccountProps , \"BankAccont\" , None ). unwrap (); Here an Entity has been created that will manage all instances of bank accounts. It will create new actors if necessary and route commands. Let's create a new bank account and make a first deposit: let number = \"12345678\" ; let name = \"Dolores Abernathy\" ; // create bank account let cmd = CQMsg :: Cmd ( number . into (), Protocol :: CreateAccountCmd ( name . into ())); em . tell ( cmd , None ); // deposit $1000 let cmd = CQMsg :: Cmd ( number . into (), Protocol :: DepositCmd ( 1000 )); em . tell ( cmd , None ); Commands require an ID and based on that ID the entity manager will route the command to the actor for that ID. If there is no currently live actor in memory for that ID the manager will start an actor. Any events associated with that ID will be loaded and the actor state restored before handling the command. Instead of managing actor creation directly using actor_of the entity manager does this instead. You will have noticed that Entity::new in the example was passed BankAccountProps . This is a struct that implements the EntityActorProps trait. Since each entity actor requires its own unique ID the standard Props used in actor_of is not sufficient. Instead EntityActorProps is implemented: struct BankAccountProps ; impl EntityActorProps for BankAccountProps { type Msg = Protocol ; fn props ( & self , id : String ) -> BoxActorProd < Self :: Msg > { Props :: new_args ( Box :: new ( BankAccountActor :: new ), id ) } } Note If other systems outside of the actor system need to view the current state, which is generally the case, materialized views can be generated and stored in a separate data storage each time an event is persisted. This provides a clear separation between the command-side and query-side of state management. By default, if an entity actor instance has no activity for more the 120 seconds the manager will put the actor in to a sleep state. During this state the actor and its state is no longer in memory. When a command is sent to an actor in sleep state it is woken up by the manager, its state restored, and the command handled. The inactivity time to sleep can be changed in riker.toml : [cqrs] # number of seconds of inactivity after which a cqrs actor will sleep sleep_after_secs = 120 To see a example project using Riker CQRS click here [TODO]","title":"Persisting State"},{"location":"persistence.html#persisting-state","text":"Riker supports persistence so that actors can restore their state when they are restarted. Riker takes an event sourcing approach to persisting data, whereby only changes to state and not the entire current state are persisted. These changes to an actor's state are considered events and are appended to the underlying event store. Actors that persist their state are often referred to as Persistent Actors.","title":"Persisting State"},{"location":"persistence.html#event-sourcing","text":"When a persistent actor restarts its state can be restored by replaying all events in the event store, specific to the actor, in the order in which they we're originally persisted. Event sourcing has several advantages over traditional data persistence methods. Since a persistent actor maintains its state in memory it's not necessary to continually read data from storage. Events are only read from the underlying storage when an actor starts. This allows for extremely high transaction rates. Event sourcing simplifies data storage since events are typically serialized objects that can be persisted to a single column or field in a database. Other non-database storage methods can also be leveraged, such as persistent queues or transaction logs. The complexities of data querying, such as database schema design and indexes aren't pertinent to event sourcing. In addition, since data structure is simplified migration between data storage solutions is made easier. An additional added value is that you get inherent auditing through the immutable nature of event sourcing - every event is recorded and remains in perpetuity.","title":"Event Sourcing"},{"location":"persistence.html#enabling-persistence","text":"An actor can be configured to persist state, i.e. be a persistent actor by returning a PersistenceConf on the persistence_conf method of the Actor trait: struct MyActor { id : String , val : u32 , } fn persistence_conf ( & self ) -> Option < PersistenceConf > { let conf = PersistenceConf { id : self . id . clone (), keyspace : \"my-actor\" . to_string () }; Some ( conf ) } The combiniation of id and keyspace allow the underlying event storage to separate events so that when an actor re/starts only the events for that actor are queried. How these fields are used depends exclusively on the event store module used. Warning Events must be specific to an actual actor instance. Load balancing two actors representing the same logical entity, for example a specific user, will conflict since only the actor handling the event will update its state.","title":"Enabling Persistence"},{"location":"persistence.html#persisting-events","text":"A persistent actor uses the ctx.persist_event method to actually persist state. Like all other Actor operations in Riker this is a non-blocking operation: fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Option < ActorRef < Self :: Msg >> ) { ctx . persist_event ( msg ); // <-- schedule event to be persisted } Here we see that ctx.persist_event is used to request the event to be stored. In this case we're using the message received as the event, but this could be any rust type that is part of your configured protocol. There are two important concepts to highlight at this point: persist_event is a non-blocking operation and execution will continue There are no guarantees that the event will be successfully stored Since these two factors hold it is important to refrain from making any state change until it is known that the event has been successfully written to the event store. The event store is responsible for signaling back to the actor when an event has been successfully committed to storage. When ctx.persist_event is invoked a persistent actor enters a 'persisting' state. During this state no further messages will be handled by the actor until the event store signals back that the event was successfully stored. This occurs to provide a guarantee that when the next message to be handled by receive the actor has the latest state. An actor's apply_event method is invoked when an event is successfully stored: fn apply_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val = evt ; // <-- safe to update the state // Its also safe to create side effects here // e.g. // `some_actor.tell(\"your support request was received\", None);` } It's here in apply_event that state can be safely mutated, since any failure at this stage means that the event will be replayed when the actor restarts. Warning Never make state changes in receive of a persistent actor.","title":"Persisting Events"},{"location":"persistence.html#replaying-events","text":"When a persistent actor starts its events are queried based on the configured id and keyspace . It is guaranteed that no messages will be handled by receive until the persistent actor finishes replaying all events. The query to load events is a non-blocking operation. Once all events have been queried the replay_event method is invoked for each event: fn replay_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val += evt ; // <-- safe to update the state // It is *not* safe to create side effects in replay_event } replay_event is similar to apply_event in that state should be mutated in this method. However, there may be undesirable side effects during replay that were necessary during the initial persistence, such as sending other messages. For example, if your actor sends email messages to customers each time they make a request you don't want to send these messages each time your actor restarts. Let's see a complete example of a persistent actor: struct MyActor { id : String , val : u32 , } impl Actor for MyActor { type Msg = u32 ; fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , _sender : Option < ActorRef < Self :: Msg >> ) { ctx . persist_event ( msg ); } fn persistence_conf ( & self ) -> Option < PersistenceConf > { let conf = PersistenceConf { id : self . id . clone (), keyspace : \"my-actor\" . to_string () }; Some ( conf ) } fn apply_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val += evt ; } fn replay_event ( & mut self , _ctx : & Context < Self :: Msg > , evt : Self :: Msg ) { self . val += evt ; } }","title":"Replaying Events"},{"location":"persistence.html#event-store","text":"In Riker events are persisted to an 'event store' configured in the model when the actor system is created. The event store is responsible for storing and loading events. To support your specific storage or database the EventStore trait can be implemented: pub trait EventStore : Clone + Send + Sync + 'static { type Msg : Message ; fn new ( config : & Config ) -> Self ; fn insert ( & mut self , id : & String , keyspace : & String , evt : Evt < Self :: Msg > ); fn load ( & self , id : & String , keyspace : & String ) -> Vec < Self :: Msg > ; } An implementation of EventStore simply needs to provide an instance of Self in the new function that will be invoked when the actor system starts. insert and load methods perform any serialization and deserialization necessary. The methods are invoked when persist_event is used and when an actor starts respectively. Note Since an event store only contains events and not whole state data can be serialized and stored in a single column of a database table for example. CBOR, JSON, MessagePack or any other serialization format could be used. The default model uses a simple in-memory event store which can be useful in tests and simple applications. All events are lost when the actor system is stopped.","title":"Event Store"},{"location":"persistence.html#cqrs","text":"Command Query Responsibility Separation (CQRS) builds of top of event sourcing to provide a more structured approach to persistence. Event sourcing alone works well for restoring individual actor state in an actor system with a fixed number of actors. This could be taken further so that data entities can be modeled as actors. For example, an entity could be a User, Account, Post, Transaction, Order, etc, where every instance is represented by its own actor instance. To make changes to an entity commands are sent to the actor representing that entity. For example, to change the password of a User entity an UpdatePasswordCmd can be sent, or to disable the user a DisableUserCmd can be sent. When an actor receives a command it validates it and then emits an event that will be persisted and applied: UpdatePasswordCmd => PasswordUpdatedEvt DisableUserCmd => UserDisabledEvt To help with setting up entities and command management Riker CQRS is a separate crate ( riker-cqrs ) that introduces: Entity management Command based messaging Since each entity has its own actor there needs to be a coordinator that creates actors when needed and routes commands to the right actor. Basic bookkeeping is also required, so that actors can sleep and be removed from memory after a period of inactivity and then restored when they're needed to handle a command. Let's look at how to set up an entity manager that represents bank accounts BankAccount : use riker_cqrs :: * ; let model : DefaultModel < TestMsg > = DefaultModel :: new (); let sys = ActorSystem :: new ( & model ). unwrap (); let em = Entity :: new ( & sys , BankAccountProps , \"BankAccont\" , None ). unwrap (); Here an Entity has been created that will manage all instances of bank accounts. It will create new actors if necessary and route commands. Let's create a new bank account and make a first deposit: let number = \"12345678\" ; let name = \"Dolores Abernathy\" ; // create bank account let cmd = CQMsg :: Cmd ( number . into (), Protocol :: CreateAccountCmd ( name . into ())); em . tell ( cmd , None ); // deposit $1000 let cmd = CQMsg :: Cmd ( number . into (), Protocol :: DepositCmd ( 1000 )); em . tell ( cmd , None ); Commands require an ID and based on that ID the entity manager will route the command to the actor for that ID. If there is no currently live actor in memory for that ID the manager will start an actor. Any events associated with that ID will be loaded and the actor state restored before handling the command. Instead of managing actor creation directly using actor_of the entity manager does this instead. You will have noticed that Entity::new in the example was passed BankAccountProps . This is a struct that implements the EntityActorProps trait. Since each entity actor requires its own unique ID the standard Props used in actor_of is not sufficient. Instead EntityActorProps is implemented: struct BankAccountProps ; impl EntityActorProps for BankAccountProps { type Msg = Protocol ; fn props ( & self , id : String ) -> BoxActorProd < Self :: Msg > { Props :: new_args ( Box :: new ( BankAccountActor :: new ), id ) } } Note If other systems outside of the actor system need to view the current state, which is generally the case, materialized views can be generated and stored in a separate data storage each time an event is persisted. This provides a clear separation between the command-side and query-side of state management. By default, if an entity actor instance has no activity for more the 120 seconds the manager will put the actor in to a sleep state. During this state the actor and its state is no longer in memory. When a command is sent to an actor in sleep state it is woken up by the manager, its state restored, and the command handled. The inactivity time to sleep can be changed in riker.toml : [cqrs] # number of seconds of inactivity after which a cqrs actor will sleep sleep_after_secs = 120 To see a example project using Riker CQRS click here [TODO]","title":"CQRS"},{"location":"riker03.html","text":"Riker 0.3 Release Notes The release of Riker 0.3 has introduced several major improvements to the design of the framework. Message Type System Prior to Riker 0.3 an actor system would share the same message type for all actors. This had critical limitations for applications, including: Cumbersome message type matching Performance hit since enum size is largest variant Library developers would need to create their own actor system Riker 0.3 has addressed these limitations by: Each actor has its own message type: struct MyStringActor ; impl Actor for MyStringActor { type Msg = String ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { println ! ( \"received String {}\" , msg ); } } struct MyU32Actor ; impl Actor for MyU32Actor { type Msg = u32 ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { println ! ( \"received u32 {}\" , msg ); } } let props = Props :: new ( Box :: new ( MyStringActor :: new )); let my_string = sys . actor_of ( props , \"my-string\" ). unwrap (); my_string . tell ( \"hello\" . to_string (), None ); let props = Props :: new ( Box :: new ( MyU32Actor :: new )); let my_u32 = sys . actor_of ( props , \"my-u32\" ). unwrap (); my_u32 . tell ( 1 , None ); Introduction of a Receive<T> trait and #[actor] attribute to streamline actors receiving more than one message type. #[actor(String, u32)] struct MyActor ; impl Actor for MyActor { type Msg = MyActorMsg ; .. . } impl Receive < String > for MyActor { type Msg = MyActorMsg ; fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : String , sender : Sender ) { println ! ( \"received String {}\" , msg ); } } impl Receive < u32 > for MyActor { type Msg = MyActorMsg ; fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : u32 , sender : Sender ) { println ! ( \"received u32 {}\" , msg ); } } let props = Props :: new ( Box :: new ( MyActor :: new )); let my_actor = sys . actor_of ( props , \"my-actor\" ). unwrap (); // send String my_actor . tell ( \"hello\" . to_string (), None ); // send u32 my_actor . tell ( 1 , None ); Introduction of BasicActorRef , an un-typed reference to interact with actors when the typed ActorRef is not available. // Using the example actor above let sel = sys . select ( \"/user/my-actor\" ). unwrap (); // send String sel . try_tell ( \"hello\" . to_string (), None ); // send u32 sel . try_tell ( 1 , None ); try_tell is the method used to send messages to BasicActorRef s, with a result return type used to indicate if the actor accepted the message type. If the message provided is not supported by the actor Err will be returned. Removal of Model Riker 0.3 used the Model trait to customize the actor system. This was found to be cumbersome and unnecessary. Riker is now included in a single crate and an actor system can be created with a single line that will use built-in defaults. When customization is required a builder is available. // Typical pre-0.3 model: // let model: DefaultModel<String> = DefaultModel::new(); // 0.3 requires only ActorSystem let sys = ActorSystem :: new (). unwrap (); Execution Fixed to Futures::ThreadPool Previous versions of Riker allowed for different futures executors to be used as part of system customization. This caused many issues especially with the evolution of Rust's async/await!. Futures could not be reliably run within actors - a major blocker on Riker's use in production systems. The decision was made to tie Riker's execution to futures::ThreadPool, which was the default executor previously. This also allows Rust applications to pass around futures between Riker and other application components that use ThreadPool. The builder allows a ThreadPool reference to be passed. // clone the executor reference from its original let exec = exec . clone (); let sys = SystemBuilder :: new () . exec ( exec ) . create () . unwrap (); Removal of Main Thread Prior to Riker 0.3 a main thread, or kernel, was used that would be tasked with scheduling actors for execution. This prevented the ability to support a truly multi message typed system and also had a performance impact. In Riker 0.3 , each actor maintains its own lightweight kernel. Trait Objects Riker 0.3 no longer handles Actors as trait objects, as a result of each actor using its own kernel. This removes the limitations inherent with trait objects and improves performance. Important Unresolved Limitations Event Sourcing has not be made available, yet, in Riker 0.3 . This has been impacted by the message system redesign and we're looking at a redesign of what event sourcing should look like in Riker 0.3 . We'd also like to point out that Riker 0.3 has not yet gone through basic performance optimization, removing unnecessary clones, using references over values where possible, etc. In particular ActorSystem requires optimization.","title":"Riker 0.3"},{"location":"riker03.html#riker-03-release-notes","text":"The release of Riker 0.3 has introduced several major improvements to the design of the framework.","title":"Riker 0.3 Release Notes"},{"location":"riker03.html#message-type-system","text":"Prior to Riker 0.3 an actor system would share the same message type for all actors. This had critical limitations for applications, including: Cumbersome message type matching Performance hit since enum size is largest variant Library developers would need to create their own actor system Riker 0.3 has addressed these limitations by: Each actor has its own message type: struct MyStringActor ; impl Actor for MyStringActor { type Msg = String ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { println ! ( \"received String {}\" , msg ); } } struct MyU32Actor ; impl Actor for MyU32Actor { type Msg = u32 ; fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { println ! ( \"received u32 {}\" , msg ); } } let props = Props :: new ( Box :: new ( MyStringActor :: new )); let my_string = sys . actor_of ( props , \"my-string\" ). unwrap (); my_string . tell ( \"hello\" . to_string (), None ); let props = Props :: new ( Box :: new ( MyU32Actor :: new )); let my_u32 = sys . actor_of ( props , \"my-u32\" ). unwrap (); my_u32 . tell ( 1 , None ); Introduction of a Receive<T> trait and #[actor] attribute to streamline actors receiving more than one message type. #[actor(String, u32)] struct MyActor ; impl Actor for MyActor { type Msg = MyActorMsg ; .. . } impl Receive < String > for MyActor { type Msg = MyActorMsg ; fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : String , sender : Sender ) { println ! ( \"received String {}\" , msg ); } } impl Receive < u32 > for MyActor { type Msg = MyActorMsg ; fn receive ( & mut self , ctx : & Context < Self :: Msg > , msg : u32 , sender : Sender ) { println ! ( \"received u32 {}\" , msg ); } } let props = Props :: new ( Box :: new ( MyActor :: new )); let my_actor = sys . actor_of ( props , \"my-actor\" ). unwrap (); // send String my_actor . tell ( \"hello\" . to_string (), None ); // send u32 my_actor . tell ( 1 , None ); Introduction of BasicActorRef , an un-typed reference to interact with actors when the typed ActorRef is not available. // Using the example actor above let sel = sys . select ( \"/user/my-actor\" ). unwrap (); // send String sel . try_tell ( \"hello\" . to_string (), None ); // send u32 sel . try_tell ( 1 , None ); try_tell is the method used to send messages to BasicActorRef s, with a result return type used to indicate if the actor accepted the message type. If the message provided is not supported by the actor Err will be returned.","title":"Message Type System"},{"location":"riker03.html#removal-of-model","text":"Riker 0.3 used the Model trait to customize the actor system. This was found to be cumbersome and unnecessary. Riker is now included in a single crate and an actor system can be created with a single line that will use built-in defaults. When customization is required a builder is available. // Typical pre-0.3 model: // let model: DefaultModel<String> = DefaultModel::new(); // 0.3 requires only ActorSystem let sys = ActorSystem :: new (). unwrap ();","title":"Removal of Model"},{"location":"riker03.html#execution-fixed-to-futuresthreadpool","text":"Previous versions of Riker allowed for different futures executors to be used as part of system customization. This caused many issues especially with the evolution of Rust's async/await!. Futures could not be reliably run within actors - a major blocker on Riker's use in production systems. The decision was made to tie Riker's execution to futures::ThreadPool, which was the default executor previously. This also allows Rust applications to pass around futures between Riker and other application components that use ThreadPool. The builder allows a ThreadPool reference to be passed. // clone the executor reference from its original let exec = exec . clone (); let sys = SystemBuilder :: new () . exec ( exec ) . create () . unwrap ();","title":"Execution Fixed to Futures::ThreadPool"},{"location":"riker03.html#removal-of-main-thread","text":"Prior to Riker 0.3 a main thread, or kernel, was used that would be tasked with scheduling actors for execution. This prevented the ability to support a truly multi message typed system and also had a performance impact. In Riker 0.3 , each actor maintains its own lightweight kernel.","title":"Removal of Main Thread"},{"location":"riker03.html#trait-objects","text":"Riker 0.3 no longer handles Actors as trait objects, as a result of each actor using its own kernel. This removes the limitations inherent with trait objects and improves performance.","title":"Trait Objects"},{"location":"riker03.html#important-unresolved-limitations","text":"Event Sourcing has not be made available, yet, in Riker 0.3 . This has been impacted by the message system redesign and we're looking at a redesign of what event sourcing should look like in Riker 0.3 . We'd also like to point out that Riker 0.3 has not yet gone through basic performance optimization, removing unnecessary clones, using references over values where possible, etc. In particular ActorSystem requires optimization.","title":"Important Unresolved Limitations"},{"location":"scheduling.html","text":"Message Scheduling Riker's timer module provides scheduling features that allow messages to be sent after a given duration or at a specific time. Timer methods are exposed on both ActorSystem and Context . One-time scheduling There are two methods that provide one-time scheduling: schedule_once schedules a message to be sent after a given delay. schedule_at_time schedules a message to be sent at a given specific time. Examples: let delay = Duration :: from_secs ( 1 ); let actor = ctx . actor_of ( MyActor :: props (), \"my-actor\" ). unwrap (); ctx . schedule_once ( delay , actor , None , \"that's one small step for man\" . into ()); Here a message is scheduled to be sent to an actor after 20 seconds. let time = SystemTime :: now (); let actor = ctx . actor_of ( MyActor :: props (), \"my-actor\" ). unwrap (); ctx . schedule_at_time ( time , actor , None , \"one giant leap for mankind\" . into ()); Here a message is scheduled to be sent at the specific time time . Repeat scheduling Messages can be scheduled to be repeatedly sent at specific intervals: schedule method schedules a message to be repeatedly sent at a given interval. Example: let delay = Duration :: from_millis ( 100 ); let iterv = Duration :: from_millis ( 500 ); let actor = ctx . actor_of ( MyActor :: props (), \"my-actor\" ). unwrap (); ctx . schedule ( delay , interv , actor , None , \"a scheduled msg\" . into ()); Here a message is scheduled to be repeated every 500 milliseconds. There is also a 100 millisecond initial delay, i.e. the duration before repeating of the message begins. Note Riker's default timer module is not persistent meaning that any scheduling is lost when an application is stopped. It's optimized for short dated durations from a few milliseconds to 48 hours, or your average time between deployments. Cancelling When scheduling a message a schedule ID is returned which can be used at a later time to cancel the schedule. Example: let id = ctx . schedule ( delay , interv , actor , None , \"a scheduled msg\" . into ()); ctx . cancel_schedule ( id ); Canceling a schedule removes it from the timer and the message will no longer be sent. Some example use cases of message scheduling include: To wait for a specific time for other actors to provide input, such as bidding systems As part of workflow to provide default messages after a timeout interval To periodically wake up an actor to check a resource, such as a queue, IO or sensor To periodically publish or broadcast messages to other actors Message scheduling is a core feature of concurrent systems and can drive applications to complete their objectives. We've covered the basics of the Riker Framework. Other topics include: Configuration Running Futures Logging","title":"Message Scheduling"},{"location":"scheduling.html#message-scheduling","text":"Riker's timer module provides scheduling features that allow messages to be sent after a given duration or at a specific time. Timer methods are exposed on both ActorSystem and Context .","title":"Message Scheduling"},{"location":"scheduling.html#one-time-scheduling","text":"There are two methods that provide one-time scheduling: schedule_once schedules a message to be sent after a given delay. schedule_at_time schedules a message to be sent at a given specific time. Examples: let delay = Duration :: from_secs ( 1 ); let actor = ctx . actor_of ( MyActor :: props (), \"my-actor\" ). unwrap (); ctx . schedule_once ( delay , actor , None , \"that's one small step for man\" . into ()); Here a message is scheduled to be sent to an actor after 20 seconds. let time = SystemTime :: now (); let actor = ctx . actor_of ( MyActor :: props (), \"my-actor\" ). unwrap (); ctx . schedule_at_time ( time , actor , None , \"one giant leap for mankind\" . into ()); Here a message is scheduled to be sent at the specific time time .","title":"One-time scheduling"},{"location":"scheduling.html#repeat-scheduling","text":"Messages can be scheduled to be repeatedly sent at specific intervals: schedule method schedules a message to be repeatedly sent at a given interval. Example: let delay = Duration :: from_millis ( 100 ); let iterv = Duration :: from_millis ( 500 ); let actor = ctx . actor_of ( MyActor :: props (), \"my-actor\" ). unwrap (); ctx . schedule ( delay , interv , actor , None , \"a scheduled msg\" . into ()); Here a message is scheduled to be repeated every 500 milliseconds. There is also a 100 millisecond initial delay, i.e. the duration before repeating of the message begins. Note Riker's default timer module is not persistent meaning that any scheduling is lost when an application is stopped. It's optimized for short dated durations from a few milliseconds to 48 hours, or your average time between deployments.","title":"Repeat scheduling"},{"location":"scheduling.html#cancelling","text":"When scheduling a message a schedule ID is returned which can be used at a later time to cancel the schedule. Example: let id = ctx . schedule ( delay , interv , actor , None , \"a scheduled msg\" . into ()); ctx . cancel_schedule ( id ); Canceling a schedule removes it from the timer and the message will no longer be sent. Some example use cases of message scheduling include: To wait for a specific time for other actors to provide input, such as bidding systems As part of workflow to provide default messages after a timeout interval To periodically wake up an actor to check a resource, such as a queue, IO or sensor To periodically publish or broadcast messages to other actors Message scheduling is a core feature of concurrent systems and can drive applications to complete their objectives. We've covered the basics of the Riker Framework. Other topics include: Configuration Running Futures Logging","title":"Cancelling"},{"location":"selection.html","text":"Actor Selection The primary means to interact with an actor is through it's actor reference ( ActorRef ). Since every actor also has a path it's possible to 'lookup' an actor by that path. It's also possible to interact with all actors that are part of a path. For example, if an actor is known to live at /user/comms/high_gain_1 , but we don't have the actor reference for this actor, we can perform a selection: let hga = ctx . select ( \"/user/comms/high_gain_1\" ). unwrap (); This will return an ActorSelection . In some ways an ActorSelection behaves like an ActorRef but represents a collection of actors. When sending a message to a seclection all the actors in the selection that accept the sent message type will receive the message. To send messages to a selection: let hga = ctx . select ( \"/user/comms/high_gain_1\" ). unwrap (); hga . try_tell ( \"I've arrived safely\" . into (), None ); try_tell is the method used to send messages since a selection is a collection of BasicActorRef s. Any message sent to an actor in the selection that rejects the message type will be dropped. While this example highlights how it's possible to message actors based on their path in practice it should be carefully considered. ActorRef (and even BasicActorRef ) is almost always the better choice for actor interaction since messages are directly sent to the actor's mailbox without any preprocessing or cloning. However there are several use cases where ActorSelection makes sense: You know the path of an actor but due to design you don't have its ActorRef You want to broadcast a message to all actors within a path It is possible to select all actors under an actor path and send the same message the actors in the selection: let sel = ctx . selection ( \"/user/home-control/lighting/*\" ). unwrap (); sel . try_tell ( Protocol :: Off , None ); In this example an actor responsible for lighting in a home has a child actor for each individual light. If we want to turn off all lights a control message ( Protocol::Off ) could be sent to /user/home-control/lighting/* . Each child actor will receive the same message. Note Paths are relative to the location where the selection is being made. E.g. from the actor lighting 's context, all children could be selected using ctx.selection(\"*\") . We've seen that ActorSelection provides flexibility for certain use cases such as when an ActorRef isn't known at compile time, but more specifically for messaging multiple actors. This comes at the cost of traversing part of the actor hierarchy and cloning messages. Next we'll see how Channels provide publish/subscribe features to enable actor choreography. Channels","title":"Actor Selection"},{"location":"selection.html#actor-selection","text":"The primary means to interact with an actor is through it's actor reference ( ActorRef ). Since every actor also has a path it's possible to 'lookup' an actor by that path. It's also possible to interact with all actors that are part of a path. For example, if an actor is known to live at /user/comms/high_gain_1 , but we don't have the actor reference for this actor, we can perform a selection: let hga = ctx . select ( \"/user/comms/high_gain_1\" ). unwrap (); This will return an ActorSelection . In some ways an ActorSelection behaves like an ActorRef but represents a collection of actors. When sending a message to a seclection all the actors in the selection that accept the sent message type will receive the message. To send messages to a selection: let hga = ctx . select ( \"/user/comms/high_gain_1\" ). unwrap (); hga . try_tell ( \"I've arrived safely\" . into (), None ); try_tell is the method used to send messages since a selection is a collection of BasicActorRef s. Any message sent to an actor in the selection that rejects the message type will be dropped. While this example highlights how it's possible to message actors based on their path in practice it should be carefully considered. ActorRef (and even BasicActorRef ) is almost always the better choice for actor interaction since messages are directly sent to the actor's mailbox without any preprocessing or cloning. However there are several use cases where ActorSelection makes sense: You know the path of an actor but due to design you don't have its ActorRef You want to broadcast a message to all actors within a path It is possible to select all actors under an actor path and send the same message the actors in the selection: let sel = ctx . selection ( \"/user/home-control/lighting/*\" ). unwrap (); sel . try_tell ( Protocol :: Off , None ); In this example an actor responsible for lighting in a home has a child actor for each individual light. If we want to turn off all lights a control message ( Protocol::Off ) could be sent to /user/home-control/lighting/* . Each child actor will receive the same message. Note Paths are relative to the location where the selection is being made. E.g. from the actor lighting 's context, all children could be selected using ctx.selection(\"*\") . We've seen that ActorSelection provides flexibility for certain use cases such as when an ActorRef isn't known at compile time, but more specifically for messaging multiple actors. This comes at the cost of traversing part of the actor hierarchy and cloning messages. Next we'll see how Channels provide publish/subscribe features to enable actor choreography. Channels","title":"Actor Selection"},{"location":"supervision.html","text":"Fault Tolerance Riker applications exhibit fault tolerant behavior through self-healing. This is achieved by supervision - each actor has a supervisor that is responsible for determining what to do if the actor panics. In Riker, an actor's parent is its supervisor. This 'parental supervision' is a natural fit since the actor system is a hierarchy. When an actor fails we can't guarantee its state is not corrupted. Its parent has three choices (strategies): Restart the actor Escalate up to the next supervisor Stop the actor Supervision isolates failures and errors don't leak or cascade. Instead the system can decide the best way to restore to a clean, working state, or to gracefully stop. The supervision strategy an actor should use to supervise its children can be set in its supervisor_strategy method: fn supervisor_strategy(&self) -> Strategy { Strategy::Stop } In this case, if a child fails it will choose to stop it. Note If supervisor_strategy is not set, the default implementation is Strategy::Restart . Mailboxes An actor has its own mailbox that messages are queued to during message delivery. When a message is sent to an actor it is added to the actor's mailbox and the actor is then scheduled to run. If during handling of a message the actor fails (panics) messages can still continue to be sent to the actor since the mailbox is separate. This allows the supervisor to handle the failure without losing messages - a restarted actor will then continue handling the queued messages once it restarts. An actor's mailbox continues to exist until its actor is stopped or the system is stopped. Restart Strategy fn supervisor_strategy(&self) -> Strategy { Strategy::Restart } The restart strategy attempts to restart the actor in its initial state, which is considered to be uncorrupted. The sequence followed is: The actor's mailbox is suspended. Messages can be received but they won't be handled All children of the failed actor are sent termination requests Wait for all children to terminate - a non-blocking operation Restart the failed actor Resume the actor's mailbox and message handling supervision_restart.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Clone, Debug)] pub struct Panic ; #[derive(Default)] struct DumbActor ; impl Actor for DumbActor { type Msg = (); fn recv ( & mut self , _ : & Context < Self :: Msg > , _ : Self :: Msg , _ : Sender ) {} } #[actor(Panic)] #[derive(Default)] struct PanicActor ; impl Actor for PanicActor { type Msg = PanicActorMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { ctx . actor_of :: < DumbActor > ( \"child_a\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_b\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_c\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_d\" ). unwrap (); } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < Panic > for PanicActor { type Msg = PanicActorMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { panic ! ( \"// TEST PANIC // TEST PANIC // TEST PANIC //\" ); } } // Test Restart Strategy #[actor(Panic)] #[derive(Default)] struct RestartSup { actor_to_fail : Option < ActorRef < PanicActorMsg >> , } impl Actor for RestartSup { type Msg = RestartSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . actor_to_fail = ctx . actor_of :: < PanicActor > ( \"actor-to-fail\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Restart } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ) } } impl Receive < Panic > for RestartSup { type Msg = RestartSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . actor_to_fail . as_ref (). unwrap (). tell ( Panic , None ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let sup = sys . actor_of :: < RestartSup > ( \"supervisor\" ). unwrap (); // println!(\"Child not added yet\"); // sys.print_tree(); println ! ( \"Before panic we see supervisor and actor that will panic!\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); sup . tell ( Panic , None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); println ! ( \"We should see panic printed, but we still alive and panic actor still here!\" ); sys . print_tree (); } Escalate Strategy fn supervisor_strategy(&self) -> Strategy { Strategy::Escalate } The escalate strategy moves the decison of how to handle the failure up to the supervisor's parent. This works by failing the current supervisor and its parent will determine how to handle the failure. The sequence followed is: The actor's mailbox is suspended. Messages can be received but they won't be handled The supervisor escalates and its mailbox is suspended The new supervisor decides which supervision strategy to follow supervision_escalate.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Clone, Debug)] pub struct Panic ; #[derive(Default)] struct DumbActor ; impl Actor for DumbActor { type Msg = (); fn recv ( & mut self , _ : & Context < Self :: Msg > , _ : Self :: Msg , _ : Sender ) {} } #[actor(Panic)] #[derive(Default)] struct PanicActor ; impl Actor for PanicActor { type Msg = PanicActorMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { ctx . actor_of :: < DumbActor > ( \"child_a\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_b\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_c\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_d\" ). unwrap (); } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < Panic > for PanicActor { type Msg = PanicActorMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { panic ! ( \"// TEST PANIC // TEST PANIC // TEST PANIC //\" ); } } #[actor(Panic)] #[derive(Default)] struct EscalateSup { actor_to_fail : Option < ActorRef < PanicActorMsg >> , } impl Actor for EscalateSup { type Msg = EscalateSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . actor_to_fail = ctx . actor_of :: < PanicActor > ( \"actor-to-fail\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Escalate } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); // match msg { // // We just resend the messages to the actor that we're concerned about testing // TestMsg::Panic => self.actor_to_fail.try_tell(msg, None).unwrap(), // TestMsg::Probe(_) => self.actor_to_fail.try_tell(msg, None).unwrap(), // }; } } impl Receive < Panic > for EscalateSup { type Msg = EscalateSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . actor_to_fail . as_ref (). unwrap (). tell ( Panic , None ); } } #[actor(Panic)] #[derive(Default)] struct EscRestartSup { escalator : Option < ActorRef < EscalateSupMsg >> , } impl Actor for EscRestartSup { type Msg = EscRestartSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . escalator = ctx . actor_of :: < EscalateSup > ( \"escalate-supervisor\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Restart } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); // match msg { // // We resend the messages to the parent of the actor that is/has panicked // TestMsg::Panic => self.escalator.try_tell(msg, None).unwrap(), // TestMsg::Probe(_) => self.escalator.try_tell(msg, None).unwrap(), // }; } } impl Receive < Panic > for EscRestartSup { type Msg = EscRestartSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . escalator . as_ref (). unwrap (). tell ( Panic , None ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let sup = sys . actor_of :: < EscRestartSup > ( \"supervisor\" ). unwrap (); println ! ( \"Before panic we see supervisor and actor that will panic!\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); sup . tell ( Panic , None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); println ! ( \"We should see panic printed, but we still alive and panic actor still here!\" ); sys . print_tree (); } Stop Strategy fn supervisor_strategy(&self) -> Strategy { Strategy::Stop } The stop strategy stops the failed actor, removing it and its mailbox from the system. supervision_stop.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Clone, Debug)] pub struct Panic ; #[derive(Default)] struct DumbActor ; impl Actor for DumbActor { type Msg = (); fn recv ( & mut self , _ : & Context < Self :: Msg > , _ : Self :: Msg , _ : Sender ) {} } #[actor(Panic)] #[derive(Default)] struct PanicActor ; impl Actor for PanicActor { type Msg = PanicActorMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { ctx . actor_of :: < DumbActor > ( \"child_a\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_b\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_c\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_d\" ). unwrap (); } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < Panic > for PanicActor { type Msg = PanicActorMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { panic ! ( \"// TEST PANIC // TEST PANIC // TEST PANIC //\" ); } } // Test Restart Strategy #[actor(Panic)] #[derive(Default)] struct RestartSup { actor_to_fail : Option < ActorRef < PanicActorMsg >> , } impl Actor for RestartSup { type Msg = RestartSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . actor_to_fail = ctx . actor_of :: < PanicActor > ( \"actor-to-fail\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Stop } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ) } } impl Receive < Panic > for RestartSup { type Msg = RestartSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . actor_to_fail . as_ref (). unwrap (). tell ( Panic , None ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let sup = sys . actor_of :: < RestartSup > ( \"supervisor\" ). unwrap (); // println!(\"Child not added yet\"); // sys.print_tree(); println ! ( \"Before panic we see supervisor and actor that will panic!\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); sup . tell ( Panic , None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); println ! ( \"We should see panic printed, but we still alive and panic actor gone!\" ); sys . print_tree (); } The output will be Before panic we see supervisor and actor that will panic ! riker \u2514\u2500 system \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp \u2514\u2500 user \u2514\u2500 supervisor \u2514\u2500 actor - to - fail \u2514\u2500 child_b \u2514\u2500 child_c \u2514\u2500 child_d \u2514\u2500 child_a thread 'pool-thread-#2' panicked at '// TEST PANIC // TEST PANIC // TEST PANIC //' , examples / supervision_stop . rs : 42 : 9 ... We should see panic printed , but we still alive and panic actor gone ! riker \u2514\u2500 system \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp \u2514\u2500 user \u2514\u2500 supervisor Process finished with exit code 0 Dead letters When an actor is terminated all existing ActorRef s are invalidated. Messages sent (using tell ) are instead rerouted to dead letters, a dedicated channel that publishes undeliverable messages to any interested actors. Riker has a default subscriber, dl_logger , that simply logs dead letter messages using info! . Supervisor Design Good supervisor design is key to designing resilient, fault tolerant systems. At the core of this is creating an actor hierarchy that matches message flow and dependency. Next we'll see how actor paths can be utilized to message actors without an actor reference and broadcast to entire segments of the actor hierarchy. Actor Selection","title":"Fault Tolerance"},{"location":"supervision.html#fault-tolerance","text":"Riker applications exhibit fault tolerant behavior through self-healing. This is achieved by supervision - each actor has a supervisor that is responsible for determining what to do if the actor panics. In Riker, an actor's parent is its supervisor. This 'parental supervision' is a natural fit since the actor system is a hierarchy. When an actor fails we can't guarantee its state is not corrupted. Its parent has three choices (strategies): Restart the actor Escalate up to the next supervisor Stop the actor Supervision isolates failures and errors don't leak or cascade. Instead the system can decide the best way to restore to a clean, working state, or to gracefully stop. The supervision strategy an actor should use to supervise its children can be set in its supervisor_strategy method: fn supervisor_strategy(&self) -> Strategy { Strategy::Stop } In this case, if a child fails it will choose to stop it. Note If supervisor_strategy is not set, the default implementation is Strategy::Restart .","title":"Fault Tolerance"},{"location":"supervision.html#mailboxes","text":"An actor has its own mailbox that messages are queued to during message delivery. When a message is sent to an actor it is added to the actor's mailbox and the actor is then scheduled to run. If during handling of a message the actor fails (panics) messages can still continue to be sent to the actor since the mailbox is separate. This allows the supervisor to handle the failure without losing messages - a restarted actor will then continue handling the queued messages once it restarts. An actor's mailbox continues to exist until its actor is stopped or the system is stopped.","title":"Mailboxes"},{"location":"supervision.html#restart-strategy","text":"fn supervisor_strategy(&self) -> Strategy { Strategy::Restart } The restart strategy attempts to restart the actor in its initial state, which is considered to be uncorrupted. The sequence followed is: The actor's mailbox is suspended. Messages can be received but they won't be handled All children of the failed actor are sent termination requests Wait for all children to terminate - a non-blocking operation Restart the failed actor Resume the actor's mailbox and message handling supervision_restart.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Clone, Debug)] pub struct Panic ; #[derive(Default)] struct DumbActor ; impl Actor for DumbActor { type Msg = (); fn recv ( & mut self , _ : & Context < Self :: Msg > , _ : Self :: Msg , _ : Sender ) {} } #[actor(Panic)] #[derive(Default)] struct PanicActor ; impl Actor for PanicActor { type Msg = PanicActorMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { ctx . actor_of :: < DumbActor > ( \"child_a\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_b\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_c\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_d\" ). unwrap (); } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < Panic > for PanicActor { type Msg = PanicActorMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { panic ! ( \"// TEST PANIC // TEST PANIC // TEST PANIC //\" ); } } // Test Restart Strategy #[actor(Panic)] #[derive(Default)] struct RestartSup { actor_to_fail : Option < ActorRef < PanicActorMsg >> , } impl Actor for RestartSup { type Msg = RestartSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . actor_to_fail = ctx . actor_of :: < PanicActor > ( \"actor-to-fail\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Restart } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ) } } impl Receive < Panic > for RestartSup { type Msg = RestartSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . actor_to_fail . as_ref (). unwrap (). tell ( Panic , None ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let sup = sys . actor_of :: < RestartSup > ( \"supervisor\" ). unwrap (); // println!(\"Child not added yet\"); // sys.print_tree(); println ! ( \"Before panic we see supervisor and actor that will panic!\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); sup . tell ( Panic , None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); println ! ( \"We should see panic printed, but we still alive and panic actor still here!\" ); sys . print_tree (); }","title":"Restart Strategy"},{"location":"supervision.html#escalate-strategy","text":"fn supervisor_strategy(&self) -> Strategy { Strategy::Escalate } The escalate strategy moves the decison of how to handle the failure up to the supervisor's parent. This works by failing the current supervisor and its parent will determine how to handle the failure. The sequence followed is: The actor's mailbox is suspended. Messages can be received but they won't be handled The supervisor escalates and its mailbox is suspended The new supervisor decides which supervision strategy to follow supervision_escalate.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Clone, Debug)] pub struct Panic ; #[derive(Default)] struct DumbActor ; impl Actor for DumbActor { type Msg = (); fn recv ( & mut self , _ : & Context < Self :: Msg > , _ : Self :: Msg , _ : Sender ) {} } #[actor(Panic)] #[derive(Default)] struct PanicActor ; impl Actor for PanicActor { type Msg = PanicActorMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { ctx . actor_of :: < DumbActor > ( \"child_a\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_b\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_c\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_d\" ). unwrap (); } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < Panic > for PanicActor { type Msg = PanicActorMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { panic ! ( \"// TEST PANIC // TEST PANIC // TEST PANIC //\" ); } } #[actor(Panic)] #[derive(Default)] struct EscalateSup { actor_to_fail : Option < ActorRef < PanicActorMsg >> , } impl Actor for EscalateSup { type Msg = EscalateSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . actor_to_fail = ctx . actor_of :: < PanicActor > ( \"actor-to-fail\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Escalate } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); // match msg { // // We just resend the messages to the actor that we're concerned about testing // TestMsg::Panic => self.actor_to_fail.try_tell(msg, None).unwrap(), // TestMsg::Probe(_) => self.actor_to_fail.try_tell(msg, None).unwrap(), // }; } } impl Receive < Panic > for EscalateSup { type Msg = EscalateSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . actor_to_fail . as_ref (). unwrap (). tell ( Panic , None ); } } #[actor(Panic)] #[derive(Default)] struct EscRestartSup { escalator : Option < ActorRef < EscalateSupMsg >> , } impl Actor for EscRestartSup { type Msg = EscRestartSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . escalator = ctx . actor_of :: < EscalateSup > ( \"escalate-supervisor\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Restart } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); // match msg { // // We resend the messages to the parent of the actor that is/has panicked // TestMsg::Panic => self.escalator.try_tell(msg, None).unwrap(), // TestMsg::Probe(_) => self.escalator.try_tell(msg, None).unwrap(), // }; } } impl Receive < Panic > for EscRestartSup { type Msg = EscRestartSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . escalator . as_ref (). unwrap (). tell ( Panic , None ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let sup = sys . actor_of :: < EscRestartSup > ( \"supervisor\" ). unwrap (); println ! ( \"Before panic we see supervisor and actor that will panic!\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); sup . tell ( Panic , None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); println ! ( \"We should see panic printed, but we still alive and panic actor still here!\" ); sys . print_tree (); }","title":"Escalate Strategy"},{"location":"supervision.html#stop-strategy","text":"fn supervisor_strategy(&self) -> Strategy { Strategy::Stop } The stop strategy stops the failed actor, removing it and its mailbox from the system. supervision_stop.rs use actors_rs :: * ; use std :: time :: Duration ; #[derive(Clone, Debug)] pub struct Panic ; #[derive(Default)] struct DumbActor ; impl Actor for DumbActor { type Msg = (); fn recv ( & mut self , _ : & Context < Self :: Msg > , _ : Self :: Msg , _ : Sender ) {} } #[actor(Panic)] #[derive(Default)] struct PanicActor ; impl Actor for PanicActor { type Msg = PanicActorMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { ctx . actor_of :: < DumbActor > ( \"child_a\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_b\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_c\" ). unwrap (); ctx . actor_of :: < DumbActor > ( \"child_d\" ). unwrap (); } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < Panic > for PanicActor { type Msg = PanicActorMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { panic ! ( \"// TEST PANIC // TEST PANIC // TEST PANIC //\" ); } } // Test Restart Strategy #[actor(Panic)] #[derive(Default)] struct RestartSup { actor_to_fail : Option < ActorRef < PanicActorMsg >> , } impl Actor for RestartSup { type Msg = RestartSupMsg ; fn pre_start ( & mut self , ctx : & Context < Self :: Msg > ) { self . actor_to_fail = ctx . actor_of :: < PanicActor > ( \"actor-to-fail\" ). ok (); } fn supervisor_strategy ( & self ) -> Strategy { Strategy :: Stop } fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ) } } impl Receive < Panic > for RestartSup { type Msg = RestartSupMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Panic , _sender : Sender ) { self . actor_to_fail . as_ref (). unwrap (). tell ( Panic , None ); } } fn main () { let sys = ActorSystem :: new (). unwrap (); let sup = sys . actor_of :: < RestartSup > ( \"supervisor\" ). unwrap (); // println!(\"Child not added yet\"); // sys.print_tree(); println ! ( \"Before panic we see supervisor and actor that will panic!\" ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); sys . print_tree (); sup . tell ( Panic , None ); std :: thread :: sleep ( Duration :: from_millis ( 500 )); println ! ( \"We should see panic printed, but we still alive and panic actor gone!\" ); sys . print_tree (); } The output will be Before panic we see supervisor and actor that will panic ! riker \u2514\u2500 system \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp \u2514\u2500 user \u2514\u2500 supervisor \u2514\u2500 actor - to - fail \u2514\u2500 child_b \u2514\u2500 child_c \u2514\u2500 child_d \u2514\u2500 child_a thread 'pool-thread-#2' panicked at '// TEST PANIC // TEST PANIC // TEST PANIC //' , examples / supervision_stop . rs : 42 : 9 ... We should see panic printed , but we still alive and panic actor gone ! riker \u2514\u2500 system \u2514\u2500 sys_events \u2514\u2500 dead_letters \u2514\u2500 dl_logger \u2514\u2500 temp \u2514\u2500 user \u2514\u2500 supervisor Process finished with exit code 0","title":"Stop Strategy"},{"location":"supervision.html#dead-letters","text":"When an actor is terminated all existing ActorRef s are invalidated. Messages sent (using tell ) are instead rerouted to dead letters, a dedicated channel that publishes undeliverable messages to any interested actors. Riker has a default subscriber, dl_logger , that simply logs dead letter messages using info! .","title":"Dead letters"},{"location":"supervision.html#supervisor-design","text":"Good supervisor design is key to designing resilient, fault tolerant systems. At the core of this is creating an actor hierarchy that matches message flow and dependency. Next we'll see how actor paths can be utilized to message actors without an actor reference and broadcast to entire segments of the actor hierarchy. Actor Selection","title":"Supervisor Design"},{"location":"testing.html","text":"Testing Testing concurrent systems can be more difficult than single threaded applications, since the test itself and the application are running on separate threads. Moreover, because of Riker's resilient self-healing approach where panics are isolated, handled and the failed component restarted, detecting failures in tests proves challenging. To help make testing easier, the riker-testkit introduces a 'probe' that can be sent to actors either through messaging or as part of an actor's Props . Probes can then emit values back to the test thread. Here's an example of testing an actor restart: #[macro_use] extern crate riker_testkit ; use riker :: actors :: * ; use riker_testkit :: probe :: { Probe , ProbeReceive }; use riker_testkit :: probe :: channel :: { probe , ChannelProbe }; #[derive(Clone, Debug)] pub struct Add ; #[derive(Clone, Debug)] pub struct TestProbe ( ChannelProbe < (), () > ); #[actor(TestProbe, Add)] struct Counter { probe : Option < TestProbe > , count : u32 , } impl Counter { fn actor () -> Counter { Counter { probe : None , count : 0 } } } impl Actor for Counter { // we used the #[actor] attribute so CounterMsg is the Msg type type Msg = CounterMsg ; type Evt = (); fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < TestProbe > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , msg : TestProbe , _sender : Sender ) { self . probe = Some ( msg ) } } impl Receive < Add > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Add , _sender : Sender ) { self . count += 1 ; if self . count == 1_000_000 { self . probe . as_ref (). unwrap (). 0. event (()) } } } #[test] fn actor_tell () { let sys = ActorSystem :: new (). unwrap (); let props = Props :: new ( Box :: new ( Counter :: actor )); let actor = sys . actor_of ( props , \"me\" ). unwrap (); let ( probe , listen ) = probe (); actor . tell ( TestProbe ( probe ), None ); for _ in 0 .. 1_000_000 { actor . tell ( Add , None ); } p_assert_eq ! ( listen , ()); } This test sends a test probe to the test actor, which is keeps and uses to signal back after one million test messages were received. The macro p_assert_eq! waits (blocks) on the listener until a value is received from the probe.","title":"Testing"},{"location":"testing.html#testing","text":"Testing concurrent systems can be more difficult than single threaded applications, since the test itself and the application are running on separate threads. Moreover, because of Riker's resilient self-healing approach where panics are isolated, handled and the failed component restarted, detecting failures in tests proves challenging. To help make testing easier, the riker-testkit introduces a 'probe' that can be sent to actors either through messaging or as part of an actor's Props . Probes can then emit values back to the test thread. Here's an example of testing an actor restart: #[macro_use] extern crate riker_testkit ; use riker :: actors :: * ; use riker_testkit :: probe :: { Probe , ProbeReceive }; use riker_testkit :: probe :: channel :: { probe , ChannelProbe }; #[derive(Clone, Debug)] pub struct Add ; #[derive(Clone, Debug)] pub struct TestProbe ( ChannelProbe < (), () > ); #[actor(TestProbe, Add)] struct Counter { probe : Option < TestProbe > , count : u32 , } impl Counter { fn actor () -> Counter { Counter { probe : None , count : 0 } } } impl Actor for Counter { // we used the #[actor] attribute so CounterMsg is the Msg type type Msg = CounterMsg ; type Evt = (); fn recv ( & mut self , ctx : & Context < Self :: Msg > , msg : Self :: Msg , sender : Sender ) { self . receive ( ctx , msg , sender ); } } impl Receive < TestProbe > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , msg : TestProbe , _sender : Sender ) { self . probe = Some ( msg ) } } impl Receive < Add > for Counter { type Msg = CounterMsg ; fn receive ( & mut self , _ctx : & Context < Self :: Msg > , _msg : Add , _sender : Sender ) { self . count += 1 ; if self . count == 1_000_000 { self . probe . as_ref (). unwrap (). 0. event (()) } } } #[test] fn actor_tell () { let sys = ActorSystem :: new (). unwrap (); let props = Props :: new ( Box :: new ( Counter :: actor )); let actor = sys . actor_of ( props , \"me\" ). unwrap (); let ( probe , listen ) = probe (); actor . tell ( TestProbe ( probe ), None ); for _ in 0 .. 1_000_000 { actor . tell ( Add , None ); } p_assert_eq ! ( listen , ()); } This test sends a test probe to the test actor, which is keeps and uses to signal back after one million test messages were received. The macro p_assert_eq! waits (blocks) on the listener until a value is received from the probe.","title":"Testing"}]}