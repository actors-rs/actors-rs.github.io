


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-5.0.2">
    
    
      
        <title>Persisting State - Riker</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.07c9fbf5.min.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/palette.ecd4686e.min.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
        
<link rel="preconnect dns-prefetch" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-53076020-3","riker.rs"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}),document.addEventListener("DOMContentSwitch",function(){ga("send","pageview")})</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="white">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#persisting-state" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="Riker" class="md-header-nav__button md-logo" aria-label="Riker">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,8A3,3 0 0,0 15,5A3,3 0 0,0 12,2A3,3 0 0,0 9,5A3,3 0 0,0 12,8M12,11.54C9.64,9.35 6.5,8 3,8V19C6.5,19 9.64,20.35 12,22.54C14.36,20.35 17.5,19 21,19V8C17.5,8 14.36,9.35 12,11.54Z" /></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Riker
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Persisting State
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" /></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/riker-rs/website/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    riker-rs/website
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Riker" class="md-nav__button md-logo" aria-label="Riker">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,8A3,3 0 0,0 15,5A3,3 0 0,0 12,2A3,3 0 0,0 9,5A3,3 0 0,0 12,8M12,11.54C9.64,9.35 6.5,8 3,8V19C6.5,19 9.64,20.35 12,22.54C14.36,20.35 17.5,19 21,19V8C17.5,8 14.36,9.35 12,11.54Z" /></svg>

    </a>
    Riker
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/riker-rs/website/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    riker-rs/website
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../actors/" title="Actors" class="md-nav__link">
      Actors
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../messaging/" title="Message Types" class="md-nav__link">
      Message Types
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../hierarchy/" title="Actor Hierarchy" class="md-nav__link">
      Actor Hierarchy
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../supervision/" title="Fault Tolerance" class="md-nav__link">
      Fault Tolerance
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../selection/" title="Actor Selection" class="md-nav__link">
      Actor Selection
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../channels/" title="Channels" class="md-nav__link">
      Channels
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../scheduling/" title="Message Scheduling" class="md-nav__link">
      Message Scheduling
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../config/" title="Configuration" class="md-nav__link">
      Configuration
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../logging/" title="Logging" class="md-nav__link">
      Logging
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../futures/" title="Running Futures" class="md-nav__link">
      Running Futures
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../testing/" title="Testing" class="md-nav__link">
      Testing
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../patterns/" title="Patterns" class="md-nav__link">
      Patterns
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../faq/" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../riker03/" title="Riker 0.3" class="md-nav__link">
      Riker 0.3
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#event-sourcing" class="md-nav__link">
    Event Sourcing
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#enabling-persistence" class="md-nav__link">
    Enabling Persistence
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#persisting-events" class="md-nav__link">
    Persisting Events
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#replaying-events" class="md-nav__link">
    Replaying Events
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#event-store" class="md-nav__link">
    Event Store
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cqrs" class="md-nav__link">
    CQRS
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/riker-rs/website/edit/master/docs/persistence.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" /></svg>
                  </a>
                
                
                  
                
                
                <h1 id="persisting-state">Persisting State</h1>
<p>Riker supports persistence so that actors can restore their state when they are restarted. Riker takes an event sourcing approach to persisting data, whereby only changes to state and not the entire current state are persisted. These changes to an actor's state are considered events and are appended to the underlying event store. Actors that persist their state are often referred to as Persistent Actors.</p>
<h2 id="event-sourcing">Event Sourcing</h2>
<p>When a persistent actor restarts its state can be restored by replaying all events in the event store, specific to the actor, in the order in which they we're originally persisted. Event sourcing has several advantages over traditional data persistence methods.</p>
<p>Since a persistent actor maintains its state in memory it's not necessary to continually read data from storage. Events are only read from the underlying storage when an actor starts. This allows for extremely high transaction rates.</p>
<p>Event sourcing simplifies data storage since events are typically serialized objects that can be persisted to a single column or field in a database. Other non-database storage methods can also be leveraged, such as persistent queues or transaction logs. The complexities of data querying, such as database schema design and indexes aren't pertinent to event sourcing. In addition, since data structure is simplified migration between data storage solutions is made easier.</p>
<p>An additional added value is that you get inherent auditing through the immutable nature of event sourcing - every event is recorded and remains in perpetuity.</p>
<h2 id="enabling-persistence">Enabling Persistence</h2>
<p>An actor can be configured to persist state, i.e. be a persistent actor by returning a <code>PersistenceConf</code> on the <code>persistence_conf</code> method of the <code>Actor</code> trait:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">MyActor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">val</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">persistence_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PersistenceConf</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PersistenceConf</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">id</span>: <span class="nc">self</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">keyspace</span>: <span class="s">&quot;my-actor&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>The combiniation of <code>id</code> and <code>keyspace</code> allow the underlying event storage to separate events so that when an actor re/starts only the events for that actor are queried. How these fields are used depends exclusively on the event store module used.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Events must be specific to an actual actor instance. Load balancing two actors representing the same logical entity, for example a specific user, will conflict since only the actor handling the event will update its state. </p>
</div>
<h2 id="persisting-events">Persisting Events</h2>
<p>A persistent actor uses the <code>ctx.persist_event</code> method to actually persist state. Like all other <code>Actor</code> operations in Riker this is a non-blocking operation:</p>
<div class="codehilite"><pre><span></span><code><span class="k">fn</span> <span class="nf">receive</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">ctx</span>: <span class="kp">&amp;</span><span class="nc">Context</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">msg</span>: <span class="nc">Self</span>::<span class="n">Msg</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">_sender</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">ActorRef</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">persist_event</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;-- schedule event to be persisted</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>Here we see that <code>ctx.persist_event</code> is used to request the event to be stored. In this case we're using the message received as the event, but this could be any rust type that is part of your configured protocol. There are two important concepts to highlight at this point:</p>
<ul>
<li><code>persist_event</code> is a non-blocking operation and execution will continue</li>
<li>There are no guarantees that the event will be successfully stored</li>
</ul>
<p>Since these two factors hold it is important to refrain from making any state change until it is known that the event has been successfully written to the event store. The event store is responsible for signaling back to the actor when an event has been successfully committed to storage.</p>
<p>When <code>ctx.persist_event</code> is invoked a persistent actor enters a 'persisting' state. During this state no further messages will be handled by the actor until the event store signals back that the event was successfully stored. This occurs to provide a guarantee that when the next message to be handled by <code>receive</code> the actor has the latest state.</p>
<p>An actor's <code>apply_event</code> method is invoked when an event is successfully stored:</p>
<div class="codehilite"><pre><span></span><code><span class="k">fn</span> <span class="nf">apply_event</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">Context</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">evt</span>: <span class="nc">Self</span>::<span class="n">Msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evt</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;-- safe to update the state</span>

<span class="w">    </span><span class="c1">// Its also safe to create side effects here</span>
<span class="w">    </span><span class="c1">// e.g.</span>
<span class="w">    </span><span class="c1">// `some_actor.tell(&quot;your support request was received&quot;, None);`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>It's here in <code>apply_event</code> that state can be safely mutated, since any failure at this stage means that the event will be replayed when the actor restarts.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Never make state changes in <code>receive</code> of a persistent actor.</p>
</div>
<h2 id="replaying-events">Replaying Events</h2>
<p>When a persistent actor starts its events are queried based on the configured <code>id</code> and <code>keyspace</code>. It is guaranteed that no messages will be handled by <code>receive</code> until the persistent actor finishes replaying all events. The query to load events is a non-blocking operation.</p>
<p>Once all events have been queried the <code>replay_event</code> method is invoked for each event:</p>
<div class="codehilite"><pre><span></span><code><span class="k">fn</span> <span class="nf">replay_event</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">Context</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">evt</span>: <span class="nc">Self</span>::<span class="n">Msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">evt</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;-- safe to update the state</span>

<span class="w">    </span><span class="c1">// It is *not* safe to create side effects in replay_event</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p><code>replay_event</code> is similar to <code>apply_event</code> in that state should be mutated in this method. However, there may be undesirable side effects during replay that were necessary during the initial persistence, such as sending other messages. For example, if your actor sends email messages to customers each time they make a request you don't want to send these messages each time your actor restarts.</p>
<p>Let's see a complete example of a persistent actor:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">MyActor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">val</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Actor</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyActor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">receive</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">ctx</span>: <span class="kp">&amp;</span><span class="nc">Context</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">msg</span>: <span class="nc">Self</span>::<span class="n">Msg</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">_sender</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">ActorRef</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">ctx</span><span class="p">.</span><span class="n">persist_event</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">persistence_conf</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PersistenceConf</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">conf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PersistenceConf</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">id</span>: <span class="nc">self</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">keyspace</span>: <span class="s">&quot;my-actor&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">apply_event</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">Context</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">evt</span>: <span class="nc">Self</span>::<span class="n">Msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">evt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">replay_event</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_ctx</span>: <span class="kp">&amp;</span><span class="nc">Context</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">evt</span>: <span class="nc">Self</span>::<span class="n">Msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">evt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</code></pre></div>


<h2 id="event-store">Event Store</h2>
<p>In Riker events are persisted to an 'event store' configured in the model when the actor system is created. The event store is responsible for storing and loading events. To support your specific storage or database the <code>EventStore</code> trait can be implemented:</p>
<div class="codehilite"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">EventStore</span><span class="w"> </span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Msg</span>: <span class="nc">Message</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">config</span>: <span class="kp">&amp;</span><span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">id</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">keyspace</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">evt</span>: <span class="nc">Evt</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">id</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">keyspace</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>An implementation of <code>EventStore</code> simply needs to provide an instance of <code>Self</code> in the <code>new</code> function that will be invoked when the actor system starts. <code>insert</code> and <code>load</code> methods perform any serialization and deserialization necessary. The methods are invoked when <code>persist_event</code> is used and when an actor starts respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since an event store only contains events and not whole state data can be serialized and stored in a single column of a database table for example. CBOR, JSON, MessagePack or any other serialization format could be used.</p>
<p>The default model uses a simple in-memory event store which can be useful in tests and simple applications. All events are lost when the actor system is stopped.</p>
</div>
<h2 id="cqrs">CQRS</h2>
<p>Command Query Responsibility Separation (CQRS) builds of top of event sourcing to provide a more structured approach to persistence. Event sourcing alone works well for restoring individual actor state in an actor system with a fixed number of actors. This could be taken further so that data entities can be modeled as actors. For example, an entity could be a User, Account, Post, Transaction, Order, etc, where every instance is represented by its own actor instance.</p>
<p>To make changes to an entity commands are sent to the actor representing that entity. For example, to change the password of a <code>User</code> entity an <code>UpdatePasswordCmd</code> can be sent, or to disable the user a <code>DisableUserCmd</code> can be sent. When an actor receives a command it validates it and then emits an event that will be persisted and applied:</p>
<div class="codehilite"><pre><span></span><code><span class="err">UpdatePasswordCmd =&gt; PasswordUpdatedEvt</span>
<span class="err">DisableUserCmd =&gt; UserDisabledEvt</span>
</code></pre></div>


<p>To help with setting up entities and command management Riker CQRS is a separate crate (<code>riker-cqrs</code>) that introduces:</p>
<ul>
<li>Entity management</li>
<li>Command based messaging</li>
</ul>
<p>Since each entity has its own actor there needs to be a coordinator that creates actors when needed and routes commands to the right actor. Basic bookkeeping is also required, so that actors can sleep and be removed from memory after a period of inactivity and then restored when they're needed to handle a command.</p>
<p>Let's look at how to set up an entity manager that represents bank accounts <code>BankAccount</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">riker_cqrs</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">model</span>: <span class="nc">DefaultModel</span><span class="o">&lt;</span><span class="n">TestMsg</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultModel</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">sys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ActorSystem</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">model</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Entity</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sys</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">BankAccountProps</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="s">&quot;BankAccont&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="nb">None</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</code></pre></div>


<p>Here an <code>Entity</code> has been created that will manage all instances of bank accounts. It will create new actors if necessary and route commands.</p>
<p>Let's create a new bank account and make a first deposit:</p>
<div class="codehilite"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;12345678&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Dolores Abernathy&quot;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// create bank account</span>
<span class="kd">let</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CQMsg</span>::<span class="n">Cmd</span><span class="p">(</span><span class="n">number</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">Protocol</span>::<span class="n">CreateAccountCmd</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">into</span><span class="p">()));</span><span class="w"></span>
<span class="n">em</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>

<span class="c1">// deposit $1000</span>
<span class="kd">let</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CQMsg</span>::<span class="n">Cmd</span><span class="p">(</span><span class="n">number</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="n">Protocol</span>::<span class="n">DepositCmd</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span><span class="w"></span>
<span class="n">em</span><span class="p">.</span><span class="n">tell</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
</code></pre></div>


<p>Commands require an ID and based on that ID the entity manager will route the command to the actor for that ID. If there is no currently live actor in memory for that ID the manager will start an actor. Any events associated with that ID will be loaded and the actor state restored before handling the command.</p>
<p>Instead of managing actor creation directly using <code>actor_of</code> the entity manager does this instead. You will have noticed that <code>Entity::new</code> in the example was passed <code>BankAccountProps</code>. This is a struct that implements the <code>EntityActorProps</code> trait.</p>
<p>Since each entity actor requires its own unique ID the standard <code>Props</code> used in <code>actor_of</code> is not sufficient. Instead <code>EntityActorProps</code> is implemented:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">BankAccountProps</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">EntityActorProps</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BankAccountProps</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Protocol</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">props</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">id</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BoxActorProd</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Msg</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Props</span>::<span class="n">new_args</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">BankAccountActor</span>::<span class="n">new</span><span class="p">),</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If other systems outside of the actor system need to view the current state, which is generally the case, materialized views can be generated and stored in a separate data storage each time an event is persisted. This provides a clear separation between the command-side and query-side of state management.</p>
</div>
<p>By default, if an entity actor instance has no activity for more the 120 seconds the manager will put the actor in to a sleep state. During this state the actor and its state is no longer in memory. When a command is sent to an actor in sleep state it is woken up by the manager, its state restored, and the command handled.</p>
<p>The inactivity time to sleep can be changed in <code>riker.toml</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">[cqrs]</span>
<span class="c1"># number of seconds of inactivity after which a cqrs actor will sleep</span>
<span class="n">sleep_after_secs</span> <span class="o">=</span> <span class="mi">120</span>
</code></pre></div>


<p>To see a example project using Riker CQRS click here [TODO]</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.36cbf620.min.js"></script>
      <script src="../assets/javascripts/bundle.00c583dd.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.7f7c8775.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>